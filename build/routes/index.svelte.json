{
    "server": {
        "component": "'use strict';\n\nfunction run(fn) {\n    return fn();\n}\nfunction blank_object() {\n    return Object.create(null);\n}\nfunction run_all(fns) {\n    fns.forEach(run);\n}\n\nlet current_component;\nfunction set_current_component(component) {\n    current_component = component;\n}\nPromise.resolve();\nconst escaped = {\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;'\n};\nfunction escape(html) {\n    return String(html).replace(/[\"'&<>]/g, match => escaped[match]);\n}\nlet on_destroy;\nfunction create_ssr_component(fn) {\n    function $$render(result, props, bindings, slots, context) {\n        const parent_component = current_component;\n        const $$ = {\n            on_destroy,\n            context: new Map(context || (parent_component ? parent_component.$$.context : [])),\n            // these will be immediately discarded\n            on_mount: [],\n            before_update: [],\n            after_update: [],\n            callbacks: blank_object()\n        };\n        set_current_component({ $$ });\n        const html = fn(result, props, bindings, slots);\n        set_current_component(parent_component);\n        return html;\n    }\n    return {\n        render: (props = {}, { $$slots = {}, context = new Map() } = {}) => {\n            on_destroy = [];\n            const result = { title: '', head: '', css: new Set() };\n            const html = $$render(result, props, {}, $$slots, context);\n            run_all(on_destroy);\n            return {\n                html,\n                css: {\n                    code: Array.from(result.css).map(css => css.code).join('\\n'),\n                    map: null // TODO\n                },\n                head: result.title + result.head\n            };\n        },\n        $$render\n    };\n}\n\n/* src\\routes\\index.svelte generated by Svelte v3.44.1 */\n\nconst css = {\n\tcode: \"main.svelte-1nzdlje{color:#f2f4f7;text-align:center;font-size:16px}h1.svelte-1nzdlje{color:#facb49;text-shadow:0px 4px 4px #7c2323;margin-top:4em}.card.svelte-1nzdlje{color:#141414;margin-top:6em;margin-left:auto;margin-right:auto;border:0;border-radius:0.6em;background:#f0f0f0;width:18em;box-shadow:2px 8px 4px rgba(0, 0, 0, 0.24), -2px 8px 4px rgba(0, 0, 0, 0.24);padding-top:1em;padding-bottom:1em}legend.svelte-1nzdlje{color:#655f68;font-size:1em;font-family:Impact, Haettenschweiler, \\\"Arial Narrow Bold\\\", sans-serif}h4.svelte-1nzdlje{margin:0;margin-top:0.4em;margin-bottom:1.6em;font-size:1.4em;font-family:\\\"Gill Sans\\\", \\\"Gill Sans MT\\\", Calibri, \\\"Trebuchet MS\\\", sans-serif;text-shadow:2px 4px 4px #b8b8b8}\",\n\tmap: \"{\\\"version\\\":3,\\\"file\\\":\\\"index.svelte\\\",\\\"sources\\\":[\\\"index.svelte\\\"],\\\"sourcesContent\\\":[\\\"<script>\\\\r\\\\n    export let gameIdeaObj;\\\\r\\\\n\\\\r\\\\n    let style = gameIdeaObj.style;\\\\r\\\\n    let theme = gameIdeaObj.theme;\\\\r\\\\n    let genre = gameIdeaObj.genre;\\\\r\\\\n</script>\\\\r\\\\n\\\\r\\\\n<style>main {\\\\n  color: #f2f4f7;\\\\n  text-align: center;\\\\n  font-size: 16px;\\\\n}\\\\n\\\\nh1 {\\\\n  color: #facb49;\\\\n  text-shadow: 0px 4px 4px #7c2323;\\\\n  margin-top: 4em;\\\\n}\\\\n\\\\n.card {\\\\n  color: #141414;\\\\n  margin-top: 6em;\\\\n  margin-left: auto;\\\\n  margin-right: auto;\\\\n  border: 0;\\\\n  border-radius: 0.6em;\\\\n  background: #f0f0f0;\\\\n  width: 18em;\\\\n  box-shadow: 2px 8px 4px rgba(0, 0, 0, 0.24), -2px 8px 4px rgba(0, 0, 0, 0.24);\\\\n  padding-top: 1em;\\\\n  padding-bottom: 1em;\\\\n}\\\\n\\\\nlegend {\\\\n  color: #655f68;\\\\n  font-size: 1em;\\\\n  font-family: Impact, Haettenschweiler, \\\\\\\"Arial Narrow Bold\\\\\\\", sans-serif;\\\\n}\\\\n\\\\nh4 {\\\\n  margin: 0;\\\\n  margin-top: 0.4em;\\\\n  margin-bottom: 1.6em;\\\\n  font-size: 1.4em;\\\\n  font-family: \\\\\\\"Gill Sans\\\\\\\", \\\\\\\"Gill Sans MT\\\\\\\", Calibri, \\\\\\\"Trebuchet MS\\\\\\\", sans-serif;\\\\n  text-shadow: 2px 4px 4px #b8b8b8;\\\\n}</style>\\\\r\\\\n\\\\r\\\\n<main>\\\\r\\\\n    <h1>Game Idea Generator</h1>\\\\r\\\\n\\\\r\\\\n    <div class=\\\\\\\"card\\\\\\\">\\\\r\\\\n        <legend>STYLE</legend>\\\\r\\\\n        <h4>{style}</h4>\\\\r\\\\n        <legend>THEME</legend>\\\\r\\\\n        <h4>{theme}</h4>\\\\r\\\\n        <legend>GENRE</legend>\\\\r\\\\n        <h4>{genre}</h4>\\\\r\\\\n    </div>\\\\r\\\\n</main>\\\\r\\\\n\\\"],\\\"names\\\":[],\\\"mappings\\\":\\\"AAQO,IAAI,eAAC,CAAC,AACX,KAAK,CAAE,OAAO,CACd,UAAU,CAAE,MAAM,CAClB,SAAS,CAAE,IAAI,AACjB,CAAC,AAED,EAAE,eAAC,CAAC,AACF,KAAK,CAAE,OAAO,CACd,WAAW,CAAE,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,OAAO,CAChC,UAAU,CAAE,GAAG,AACjB,CAAC,AAED,KAAK,eAAC,CAAC,AACL,KAAK,CAAE,OAAO,CACd,UAAU,CAAE,GAAG,CACf,WAAW,CAAE,IAAI,CACjB,YAAY,CAAE,IAAI,CAClB,MAAM,CAAE,CAAC,CACT,aAAa,CAAE,KAAK,CACpB,UAAU,CAAE,OAAO,CACnB,KAAK,CAAE,IAAI,CACX,UAAU,CAAE,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAC7E,WAAW,CAAE,GAAG,CAChB,cAAc,CAAE,GAAG,AACrB,CAAC,AAED,MAAM,eAAC,CAAC,AACN,KAAK,CAAE,OAAO,CACd,SAAS,CAAE,GAAG,CACd,WAAW,CAAE,MAAM,CAAC,CAAC,gBAAgB,CAAC,CAAC,mBAAmB,CAAC,CAAC,UAAU,AACxE,CAAC,AAED,EAAE,eAAC,CAAC,AACF,MAAM,CAAE,CAAC,CACT,UAAU,CAAE,KAAK,CACjB,aAAa,CAAE,KAAK,CACpB,SAAS,CAAE,KAAK,CAChB,WAAW,CAAE,WAAW,CAAC,CAAC,cAAc,CAAC,CAAC,OAAO,CAAC,CAAC,cAAc,CAAC,CAAC,UAAU,CAC7E,WAAW,CAAE,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,OAAO,AAClC,CAAC\\\"}\"\n};\n\nconst Routes = create_ssr_component(($$result, $$props, $$bindings, slots) => {\n\tlet { gameIdeaObj } = $$props;\n\tlet style = gameIdeaObj.style;\n\tlet theme = gameIdeaObj.theme;\n\tlet genre = gameIdeaObj.genre;\n\tif ($$props.gameIdeaObj === void 0 && $$bindings.gameIdeaObj && gameIdeaObj !== void 0) $$bindings.gameIdeaObj(gameIdeaObj);\n\t$$result.css.add(css);\n\n\treturn `<main class=\"${\"svelte-1nzdlje\"}\"><h1 class=\"${\"svelte-1nzdlje\"}\">Game Idea Generator</h1>\r\n\r\n    <div class=\"${\"card svelte-1nzdlje\"}\"><legend class=\"${\"svelte-1nzdlje\"}\">STYLE</legend>\r\n        <h4 class=\"${\"svelte-1nzdlje\"}\">${escape(style)}</h4>\r\n        <legend class=\"${\"svelte-1nzdlje\"}\">THEME</legend>\r\n        <h4 class=\"${\"svelte-1nzdlje\"}\">${escape(theme)}</h4>\r\n        <legend class=\"${\"svelte-1nzdlje\"}\">GENRE</legend>\r\n        <h4 class=\"${\"svelte-1nzdlje\"}\">${escape(genre)}</h4></div></main>`;\n});\n\nmodule.exports = Routes;\n",
        "css": "main.svelte-1nzdlje{color:#f2f4f7;text-align:center;font-size:16px}h1.svelte-1nzdlje{color:#facb49;text-shadow:0px 4px 4px #7c2323;margin-top:4em}.card.svelte-1nzdlje{color:#141414;margin-top:6em;margin-left:auto;margin-right:auto;border:0;border-radius:0.6em;background:#f0f0f0;width:18em;box-shadow:2px 8px 4px rgba(0, 0, 0, 0.24), -2px 8px 4px rgba(0, 0, 0, 0.24);padding-top:1em;padding-bottom:1em}legend.svelte-1nzdlje{color:#655f68;font-size:1em;font-family:Impact, Haettenschweiler, \"Arial Narrow Bold\", sans-serif}h4.svelte-1nzdlje{margin:0;margin-top:0.4em;margin-bottom:1.6em;font-size:1.4em;font-family:\"Gill Sans\", \"Gill Sans MT\", Calibri, \"Trebuchet MS\", sans-serif;text-shadow:2px 4px 4px #b8b8b8}"
    },
    "client": {
        "js": {
            "exports": [
                "default"
            ],
            "facadeModuleId": "C:\\Users\\ignur\\Desktop\\Portfolio\\gameidea-generator\\src\\routes\\index.svelte",
            "isDynamicEntry": false,
            "isEntry": true,
            "isImplicitEntry": false,
            "modules": {
                "C:\\Users\\ignur\\Desktop\\Portfolio\\gameidea-generator\\node_modules\\svelte\\internal\\index.mjs": {
                    "code": "    function noop() { }\n    function add_location(element, file, line, column, char) {\n        element.__svelte_meta = {\n            loc: { file, line, column, char }\n        };\n    }\n    function run(fn) {\n        return fn();\n    }\n    function blank_object() {\n        return Object.create(null);\n    }\n    function run_all(fns) {\n        fns.forEach(run);\n    }\n    function is_function(thing) {\n        return typeof thing === 'function';\n    }\n    function safe_not_equal(a, b) {\n        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');\n    }\n    function is_empty(obj) {\n        return Object.keys(obj).length === 0;\n    }\n\n    // Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM\n    // at the end of hydration without touching the remaining nodes.\n    let is_hydrating = false;\n    function start_hydrating() {\n        is_hydrating = true;\n    }\n    function end_hydrating() {\n        is_hydrating = false;\n    }\n    function upper_bound(low, high, key, value) {\n        // Return first index of value larger than input value in the range [low, high)\n        while (low < high) {\n            const mid = low + ((high - low) >> 1);\n            if (key(mid) <= value) {\n                low = mid + 1;\n            }\n            else {\n                high = mid;\n            }\n        }\n        return low;\n    }\n    function init_hydrate(target) {\n        if (target.hydrate_init)\n            return;\n        target.hydrate_init = true;\n        // We know that all children have claim_order values since the unclaimed have been detached if target is not <head>\n        let children = target.childNodes;\n        // If target is <head>, there may be children without claim_order\n        if (target.nodeName === 'HEAD') {\n            const myChildren = [];\n            for (let i = 0; i < children.length; i++) {\n                const node = children[i];\n                if (node.claim_order !== undefined) {\n                    myChildren.push(node);\n                }\n            }\n            children = myChildren;\n        }\n        /*\n        * Reorder claimed children optimally.\n        * We can reorder claimed children optimally by finding the longest subsequence of\n        * nodes that are already claimed in order and only moving the rest. The longest\n        * subsequence subsequence of nodes that are claimed in order can be found by\n        * computing the longest increasing subsequence of .claim_order values.\n        *\n        * This algorithm is optimal in generating the least amount of reorder operations\n        * possible.\n        *\n        * Proof:\n        * We know that, given a set of reordering operations, the nodes that do not move\n        * always form an increasing subsequence, since they do not move among each other\n        * meaning that they must be already ordered among each other. Thus, the maximal\n        * set of nodes that do not move form a longest increasing subsequence.\n        */\n        // Compute longest increasing subsequence\n        // m: subsequence length j => index k of smallest value that ends an increasing subsequence of length j\n        const m = new Int32Array(children.length + 1);\n        // Predecessor indices + 1\n        const p = new Int32Array(children.length);\n        m[0] = -1;\n        let longest = 0;\n        for (let i = 0; i < children.length; i++) {\n            const current = children[i].claim_order;\n            // Find the largest subsequence length such that it ends in a value less than our current value\n            // upper_bound returns first greater value, so we subtract one\n            // with fast path for when we are on the current longest subsequence\n            const seqLen = ((longest > 0 && children[m[longest]].claim_order <= current) ? longest + 1 : upper_bound(1, longest, idx => children[m[idx]].claim_order, current)) - 1;\n            p[i] = m[seqLen] + 1;\n            const newLen = seqLen + 1;\n            // We can guarantee that current is the smallest value. Otherwise, we would have generated a longer sequence.\n            m[newLen] = i;\n            longest = Math.max(newLen, longest);\n        }\n        // The longest increasing subsequence of nodes (initially reversed)\n        const lis = [];\n        // The rest of the nodes, nodes that will be moved\n        const toMove = [];\n        let last = children.length - 1;\n        for (let cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {\n            lis.push(children[cur - 1]);\n            for (; last >= cur; last--) {\n                toMove.push(children[last]);\n            }\n            last--;\n        }\n        for (; last >= 0; last--) {\n            toMove.push(children[last]);\n        }\n        lis.reverse();\n        // We sort the nodes being moved to guarantee that their insertion order matches the claim order\n        toMove.sort((a, b) => a.claim_order - b.claim_order);\n        // Finally, we move the nodes\n        for (let i = 0, j = 0; i < toMove.length; i++) {\n            while (j < lis.length && toMove[i].claim_order >= lis[j].claim_order) {\n                j++;\n            }\n            const anchor = j < lis.length ? lis[j] : null;\n            target.insertBefore(toMove[i], anchor);\n        }\n    }\n    function append_hydration(target, node) {\n        if (is_hydrating) {\n            init_hydrate(target);\n            if ((target.actual_end_child === undefined) || ((target.actual_end_child !== null) && (target.actual_end_child.parentElement !== target))) {\n                target.actual_end_child = target.firstChild;\n            }\n            // Skip nodes of undefined ordering\n            while ((target.actual_end_child !== null) && (target.actual_end_child.claim_order === undefined)) {\n                target.actual_end_child = target.actual_end_child.nextSibling;\n            }\n            if (node !== target.actual_end_child) {\n                // We only insert if the ordering of this node should be modified or the parent node is not target\n                if (node.claim_order !== undefined || node.parentNode !== target) {\n                    target.insertBefore(node, target.actual_end_child);\n                }\n            }\n            else {\n                target.actual_end_child = node.nextSibling;\n            }\n        }\n        else if (node.parentNode !== target || node.nextSibling !== null) {\n            target.appendChild(node);\n        }\n    }\n    function insert_hydration(target, node, anchor) {\n        if (is_hydrating && !anchor) {\n            append_hydration(target, node);\n        }\n        else if (node.parentNode !== target || node.nextSibling != anchor) {\n            target.insertBefore(node, anchor || null);\n        }\n    }\n    function detach(node) {\n        node.parentNode.removeChild(node);\n    }\n    function element(name) {\n        return document.createElement(name);\n    }\n    function text(data) {\n        return document.createTextNode(data);\n    }\n    function space() {\n        return text(' ');\n    }\n    function attr(node, attribute, value) {\n        if (value == null)\n            node.removeAttribute(attribute);\n        else if (node.getAttribute(attribute) !== value)\n            node.setAttribute(attribute, value);\n    }\n    function children(element) {\n        return Array.from(element.childNodes);\n    }\n    function init_claim_info(nodes) {\n        if (nodes.claim_info === undefined) {\n            nodes.claim_info = { last_index: 0, total_claimed: 0 };\n        }\n    }\n    function claim_node(nodes, predicate, processNode, createNode, dontUpdateLastIndex = false) {\n        // Try to find nodes in an order such that we lengthen the longest increasing subsequence\n        init_claim_info(nodes);\n        const resultNode = (() => {\n            // We first try to find an element after the previous one\n            for (let i = nodes.claim_info.last_index; i < nodes.length; i++) {\n                const node = nodes[i];\n                if (predicate(node)) {\n                    const replacement = processNode(node);\n                    if (replacement === undefined) {\n                        nodes.splice(i, 1);\n                    }\n                    else {\n                        nodes[i] = replacement;\n                    }\n                    if (!dontUpdateLastIndex) {\n                        nodes.claim_info.last_index = i;\n                    }\n                    return node;\n                }\n            }\n            // Otherwise, we try to find one before\n            // We iterate in reverse so that we don't go too far back\n            for (let i = nodes.claim_info.last_index - 1; i >= 0; i--) {\n                const node = nodes[i];\n                if (predicate(node)) {\n                    const replacement = processNode(node);\n                    if (replacement === undefined) {\n                        nodes.splice(i, 1);\n                    }\n                    else {\n                        nodes[i] = replacement;\n                    }\n                    if (!dontUpdateLastIndex) {\n                        nodes.claim_info.last_index = i;\n                    }\n                    else if (replacement === undefined) {\n                        // Since we spliced before the last_index, we decrease it\n                        nodes.claim_info.last_index--;\n                    }\n                    return node;\n                }\n            }\n            // If we can't find any matching node, we create a new one\n            return createNode();\n        })();\n        resultNode.claim_order = nodes.claim_info.total_claimed;\n        nodes.claim_info.total_claimed += 1;\n        return resultNode;\n    }\n    function claim_element_base(nodes, name, attributes, create_element) {\n        return claim_node(nodes, (node) => node.nodeName === name, (node) => {\n            const remove = [];\n            for (let j = 0; j < node.attributes.length; j++) {\n                const attribute = node.attributes[j];\n                if (!attributes[attribute.name]) {\n                    remove.push(attribute.name);\n                }\n            }\n            remove.forEach(v => node.removeAttribute(v));\n            return undefined;\n        }, () => create_element(name));\n    }\n    function claim_element(nodes, name, attributes) {\n        return claim_element_base(nodes, name, attributes, element);\n    }\n    function claim_text(nodes, data) {\n        return claim_node(nodes, (node) => node.nodeType === 3, (node) => {\n            const dataStr = '' + data;\n            if (node.data.startsWith(dataStr)) {\n                if (node.data.length !== dataStr.length) {\n                    return node.splitText(dataStr.length);\n                }\n            }\n            else {\n                node.data = dataStr;\n            }\n        }, () => text(data), true // Text nodes should not update last index since it is likely not worth it to eliminate an increasing subsequence of actual elements\n        );\n    }\n    function claim_space(nodes) {\n        return claim_text(nodes, ' ');\n    }\n    function custom_event(type, detail, bubbles = false) {\n        const e = document.createEvent('CustomEvent');\n        e.initCustomEvent(type, bubbles, false, detail);\n        return e;\n    }\n\n    let current_component;\n    function set_current_component(component) {\n        current_component = component;\n    }\n\n    const dirty_components = [];\n    const binding_callbacks = [];\n    const render_callbacks = [];\n    const flush_callbacks = [];\n    const resolved_promise = Promise.resolve();\n    let update_scheduled = false;\n    function schedule_update() {\n        if (!update_scheduled) {\n            update_scheduled = true;\n            resolved_promise.then(flush);\n        }\n    }\n    function add_render_callback(fn) {\n        render_callbacks.push(fn);\n    }\n    let flushing = false;\n    const seen_callbacks = new Set();\n    function flush() {\n        if (flushing)\n            return;\n        flushing = true;\n        do {\n            // first, call beforeUpdate functions\n            // and update components\n            for (let i = 0; i < dirty_components.length; i += 1) {\n                const component = dirty_components[i];\n                set_current_component(component);\n                update(component.$$);\n            }\n            set_current_component(null);\n            dirty_components.length = 0;\n            while (binding_callbacks.length)\n                binding_callbacks.pop()();\n            // then, once components are updated, call\n            // afterUpdate functions. This may cause\n            // subsequent updates...\n            for (let i = 0; i < render_callbacks.length; i += 1) {\n                const callback = render_callbacks[i];\n                if (!seen_callbacks.has(callback)) {\n                    // ...so guard against infinite loops\n                    seen_callbacks.add(callback);\n                    callback();\n                }\n            }\n            render_callbacks.length = 0;\n        } while (dirty_components.length);\n        while (flush_callbacks.length) {\n            flush_callbacks.pop()();\n        }\n        update_scheduled = false;\n        flushing = false;\n        seen_callbacks.clear();\n    }\n    function update($$) {\n        if ($$.fragment !== null) {\n            $$.update();\n            run_all($$.before_update);\n            const dirty = $$.dirty;\n            $$.dirty = [-1];\n            $$.fragment && $$.fragment.p($$.ctx, dirty);\n            $$.after_update.forEach(add_render_callback);\n        }\n    }\n    const outroing = new Set();\n    function transition_in(block, local) {\n        if (block && block.i) {\n            outroing.delete(block);\n            block.i(local);\n        }\n    }\n    function mount_component(component, target, anchor, customElement) {\n        const { fragment, on_mount, on_destroy, after_update } = component.$$;\n        fragment && fragment.m(target, anchor);\n        if (!customElement) {\n            // onMount happens before the initial afterUpdate\n            add_render_callback(() => {\n                const new_on_destroy = on_mount.map(run).filter(is_function);\n                if (on_destroy) {\n                    on_destroy.push(...new_on_destroy);\n                }\n                else {\n                    // Edge case - component was destroyed immediately,\n                    // most likely as a result of a binding initialising\n                    run_all(new_on_destroy);\n                }\n                component.$$.on_mount = [];\n            });\n        }\n        after_update.forEach(add_render_callback);\n    }\n    function destroy_component(component, detaching) {\n        const $$ = component.$$;\n        if ($$.fragment !== null) {\n            run_all($$.on_destroy);\n            $$.fragment && $$.fragment.d(detaching);\n            // TODO null out other refs, including component.$$ (but need to\n            // preserve final state?)\n            $$.on_destroy = $$.fragment = null;\n            $$.ctx = [];\n        }\n    }\n    function make_dirty(component, i) {\n        if (component.$$.dirty[0] === -1) {\n            dirty_components.push(component);\n            schedule_update();\n            component.$$.dirty.fill(0);\n        }\n        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));\n    }\n    function init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {\n        const parent_component = current_component;\n        set_current_component(component);\n        const $$ = component.$$ = {\n            fragment: null,\n            ctx: null,\n            // state\n            props,\n            update: noop,\n            not_equal,\n            bound: blank_object(),\n            // lifecycle\n            on_mount: [],\n            on_destroy: [],\n            on_disconnect: [],\n            before_update: [],\n            after_update: [],\n            context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n            // everything else\n            callbacks: blank_object(),\n            dirty,\n            skip_bound: false,\n            root: options.target || parent_component.$$.root\n        };\n        append_styles && append_styles($$.root);\n        let ready = false;\n        $$.ctx = instance\n            ? instance(component, options.props || {}, (i, ret, ...rest) => {\n                const value = rest.length ? rest[0] : ret;\n                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n                    if (!$$.skip_bound && $$.bound[i])\n                        $$.bound[i](value);\n                    if (ready)\n                        make_dirty(component, i);\n                }\n                return ret;\n            })\n            : [];\n        $$.update();\n        ready = true;\n        run_all($$.before_update);\n        // `false` as a special case of no DOM component\n        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n        if (options.target) {\n            if (options.hydrate) {\n                start_hydrating();\n                const nodes = children(options.target);\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                $$.fragment && $$.fragment.l(nodes);\n                nodes.forEach(detach);\n            }\n            else {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                $$.fragment && $$.fragment.c();\n            }\n            if (options.intro)\n                transition_in(component.$$.fragment);\n            mount_component(component, options.target, options.anchor, options.customElement);\n            end_hydrating();\n            flush();\n        }\n        set_current_component(parent_component);\n    }\n    /**\n     * Base class for Svelte components. Used when dev=false.\n     */\n    class SvelteComponent {\n        $destroy() {\n            destroy_component(this, 1);\n            this.$destroy = noop;\n        }\n        $on(type, callback) {\n            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n            callbacks.push(callback);\n            return () => {\n                const index = callbacks.indexOf(callback);\n                if (index !== -1)\n                    callbacks.splice(index, 1);\n            };\n        }\n        $set($$props) {\n            if (this.$$set && !is_empty($$props)) {\n                this.$$.skip_bound = true;\n                this.$$set($$props);\n                this.$$.skip_bound = false;\n            }\n        }\n    }\n\n    function dispatch_dev(type, detail) {\n        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.44.1' }, detail), true));\n    }\n    function append_hydration_dev(target, node) {\n        dispatch_dev('SvelteDOMInsert', { target, node });\n        append_hydration(target, node);\n    }\n    function insert_hydration_dev(target, node, anchor) {\n        dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n        insert_hydration(target, node, anchor);\n    }\n    function detach_dev(node) {\n        dispatch_dev('SvelteDOMRemove', { node });\n        detach(node);\n    }\n    function attr_dev(node, attribute, value) {\n        attr(node, attribute, value);\n        if (value == null)\n            dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });\n        else\n            dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });\n    }\n    function validate_slots(name, slot, keys) {\n        for (const slot_key of Object.keys(slot)) {\n            if (!~keys.indexOf(slot_key)) {\n                console.warn(`<${name}> received an unexpected slot \"${slot_key}\".`);\n            }\n        }\n    }\n    /**\n     * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.\n     */\n    class SvelteComponentDev extends SvelteComponent {\n        constructor(options) {\n            if (!options || (!options.target && !options.$$inline)) {\n                throw new Error(\"'target' is a required option\");\n            }\n            super();\n        }\n        $destroy() {\n            super.$destroy();\n            this.$destroy = () => {\n                console.warn('Component was already destroyed'); // eslint-disable-line no-console\n            };\n        }\n        $capture_state() { }\n        $inject_state() { }\n    }",
                    "originalLength": 67632,
                    "removedExports": [
                        "HtmlTag",
                        "HtmlTagHydration",
                        "SvelteComponentTyped",
                        "SvelteElement",
                        "action_destroyer",
                        "add_attribute",
                        "add_classes",
                        "add_flush_callback",
                        "add_resize_listener",
                        "add_transform",
                        "afterUpdate",
                        "append",
                        "append_dev",
                        "append_empty_stylesheet",
                        "append_styles",
                        "assign",
                        "attribute_to_object",
                        "beforeUpdate",
                        "bind",
                        "bubble",
                        "check_outros",
                        "claim_component",
                        "claim_html_tag",
                        "claim_svg_element",
                        "clear_loops",
                        "component_subscribe",
                        "compute_rest_props",
                        "compute_slots",
                        "createEventDispatcher",
                        "create_animation",
                        "create_bidirectional_transition",
                        "create_component",
                        "create_in_transition",
                        "create_out_transition",
                        "create_slot",
                        "create_ssr_component",
                        "dataset_dev",
                        "debug",
                        "destroy_block",
                        "destroy_each",
                        "detach_after_dev",
                        "detach_before_dev",
                        "detach_between_dev",
                        "each",
                        "element_is",
                        "empty",
                        "escape",
                        "escape_attribute_value",
                        "escape_object",
                        "escaped",
                        "exclude_internal_props",
                        "fix_and_destroy_block",
                        "fix_and_outro_and_destroy_block",
                        "fix_position",
                        "getAllContexts",
                        "getContext",
                        "get_all_dirty_from_scope",
                        "get_binding_group_value",
                        "get_current_component",
                        "get_custom_elements_slots",
                        "get_root_for_style",
                        "get_slot_changes",
                        "get_spread_object",
                        "get_spread_update",
                        "get_store_value",
                        "globals",
                        "group_outros",
                        "handle_promise",
                        "hasContext",
                        "has_prop",
                        "identity",
                        "insert",
                        "insert_dev",
                        "intros",
                        "invalid_attribute_name_character",
                        "is_client",
                        "is_crossorigin",
                        "is_promise",
                        "listen",
                        "listen_dev",
                        "loop",
                        "loop_guard",
                        "missing_component",
                        "not_equal",
                        "now",
                        "null_to_empty",
                        "object_without_properties",
                        "onDestroy",
                        "onMount",
                        "once",
                        "outro_and_destroy_block",
                        "prevent_default",
                        "prop_dev",
                        "query_selector_all",
                        "raf",
                        "select_multiple_value",
                        "select_option",
                        "select_options",
                        "select_value",
                        "self",
                        "setContext",
                        "set_attributes",
                        "set_custom_element_data",
                        "set_data",
                        "set_data_dev",
                        "set_input_type",
                        "set_input_value",
                        "set_now",
                        "set_raf",
                        "set_store_value",
                        "set_style",
                        "set_svg_attributes",
                        "spread",
                        "src_url_equal",
                        "stop_propagation",
                        "subscribe",
                        "svg_element",
                        "tick",
                        "time_ranges_to_array",
                        "to_number",
                        "toggle_class",
                        "transition_out",
                        "trusted",
                        "update_await_block_branch",
                        "update_keyed_each",
                        "update_slot",
                        "update_slot_base",
                        "validate_component",
                        "validate_each_argument",
                        "validate_each_keys",
                        "validate_store",
                        "xlink_attr"
                    ],
                    "renderedExports": [
                        "SvelteComponent",
                        "SvelteComponentDev",
                        "add_location",
                        "add_render_callback",
                        "append_hydration",
                        "append_hydration_dev",
                        "attr",
                        "attr_dev",
                        "binding_callbacks",
                        "blank_object",
                        "children",
                        "claim_element",
                        "claim_space",
                        "claim_text",
                        "current_component",
                        "custom_event",
                        "destroy_component",
                        "detach",
                        "detach_dev",
                        "dirty_components",
                        "dispatch_dev",
                        "element",
                        "end_hydrating",
                        "flush",
                        "init",
                        "insert_hydration",
                        "insert_hydration_dev",
                        "is_empty",
                        "is_function",
                        "mount_component",
                        "noop",
                        "run",
                        "run_all",
                        "safe_not_equal",
                        "schedule_update",
                        "set_current_component",
                        "space",
                        "start_hydrating",
                        "text",
                        "transition_in",
                        "validate_slots"
                    ],
                    "renderedLength": 18334
                },
                "C:\\Users\\ignur\\Desktop\\Portfolio\\gameidea-generator\\src\\routes\\index.svelte": {
                    "code": "    /* src\\routes\\index.svelte generated by Svelte v3.44.1 */\n\n    const file = \"src\\\\routes\\\\index.svelte\";\n\n    function create_fragment(ctx) {\n    \tlet main;\n    \tlet h1;\n    \tlet t0;\n    \tlet t1;\n    \tlet div;\n    \tlet legend0;\n    \tlet t2;\n    \tlet t3;\n    \tlet h40;\n    \tlet t4;\n    \tlet t5;\n    \tlet legend1;\n    \tlet t6;\n    \tlet t7;\n    \tlet h41;\n    \tlet t8;\n    \tlet t9;\n    \tlet legend2;\n    \tlet t10;\n    \tlet t11;\n    \tlet h42;\n    \tlet t12;\n\n    \tconst block = {\n    \t\tc: function create() {\n    \t\t\tmain = element(\"main\");\n    \t\t\th1 = element(\"h1\");\n    \t\t\tt0 = text(\"Game Idea Generator\");\n    \t\t\tt1 = space();\n    \t\t\tdiv = element(\"div\");\n    \t\t\tlegend0 = element(\"legend\");\n    \t\t\tt2 = text(\"STYLE\");\n    \t\t\tt3 = space();\n    \t\t\th40 = element(\"h4\");\n    \t\t\tt4 = text(/*style*/ ctx[0]);\n    \t\t\tt5 = space();\n    \t\t\tlegend1 = element(\"legend\");\n    \t\t\tt6 = text(\"THEME\");\n    \t\t\tt7 = space();\n    \t\t\th41 = element(\"h4\");\n    \t\t\tt8 = text(/*theme*/ ctx[1]);\n    \t\t\tt9 = space();\n    \t\t\tlegend2 = element(\"legend\");\n    \t\t\tt10 = text(\"GENRE\");\n    \t\t\tt11 = space();\n    \t\t\th42 = element(\"h4\");\n    \t\t\tt12 = text(/*genre*/ ctx[2]);\n    \t\t\tthis.h();\n    \t\t},\n    \t\tl: function claim(nodes) {\n    \t\t\tmain = claim_element(nodes, \"MAIN\", { class: true });\n    \t\t\tvar main_nodes = children(main);\n    \t\t\th1 = claim_element(main_nodes, \"H1\", { class: true });\n    \t\t\tvar h1_nodes = children(h1);\n    \t\t\tt0 = claim_text(h1_nodes, \"Game Idea Generator\");\n    \t\t\th1_nodes.forEach(detach_dev);\n    \t\t\tt1 = claim_space(main_nodes);\n    \t\t\tdiv = claim_element(main_nodes, \"DIV\", { class: true });\n    \t\t\tvar div_nodes = children(div);\n    \t\t\tlegend0 = claim_element(div_nodes, \"LEGEND\", { class: true });\n    \t\t\tvar legend0_nodes = children(legend0);\n    \t\t\tt2 = claim_text(legend0_nodes, \"STYLE\");\n    \t\t\tlegend0_nodes.forEach(detach_dev);\n    \t\t\tt3 = claim_space(div_nodes);\n    \t\t\th40 = claim_element(div_nodes, \"H4\", { class: true });\n    \t\t\tvar h40_nodes = children(h40);\n    \t\t\tt4 = claim_text(h40_nodes, /*style*/ ctx[0]);\n    \t\t\th40_nodes.forEach(detach_dev);\n    \t\t\tt5 = claim_space(div_nodes);\n    \t\t\tlegend1 = claim_element(div_nodes, \"LEGEND\", { class: true });\n    \t\t\tvar legend1_nodes = children(legend1);\n    \t\t\tt6 = claim_text(legend1_nodes, \"THEME\");\n    \t\t\tlegend1_nodes.forEach(detach_dev);\n    \t\t\tt7 = claim_space(div_nodes);\n    \t\t\th41 = claim_element(div_nodes, \"H4\", { class: true });\n    \t\t\tvar h41_nodes = children(h41);\n    \t\t\tt8 = claim_text(h41_nodes, /*theme*/ ctx[1]);\n    \t\t\th41_nodes.forEach(detach_dev);\n    \t\t\tt9 = claim_space(div_nodes);\n    \t\t\tlegend2 = claim_element(div_nodes, \"LEGEND\", { class: true });\n    \t\t\tvar legend2_nodes = children(legend2);\n    \t\t\tt10 = claim_text(legend2_nodes, \"GENRE\");\n    \t\t\tlegend2_nodes.forEach(detach_dev);\n    \t\t\tt11 = claim_space(div_nodes);\n    \t\t\th42 = claim_element(div_nodes, \"H4\", { class: true });\n    \t\t\tvar h42_nodes = children(h42);\n    \t\t\tt12 = claim_text(h42_nodes, /*genre*/ ctx[2]);\n    \t\t\th42_nodes.forEach(detach_dev);\n    \t\t\tdiv_nodes.forEach(detach_dev);\n    \t\t\tmain_nodes.forEach(detach_dev);\n    \t\t\tthis.h();\n    \t\t},\n    \t\th: function hydrate() {\n    \t\t\tattr_dev(h1, \"class\", \"svelte-1nzdlje\");\n    \t\t\tadd_location(h1, file, 50, 4, 956);\n    \t\t\tattr_dev(legend0, \"class\", \"svelte-1nzdlje\");\n    \t\t\tadd_location(legend0, file, 53, 8, 1020);\n    \t\t\tattr_dev(h40, \"class\", \"svelte-1nzdlje\");\n    \t\t\tadd_location(h40, file, 54, 8, 1052);\n    \t\t\tattr_dev(legend1, \"class\", \"svelte-1nzdlje\");\n    \t\t\tadd_location(legend1, file, 55, 8, 1078);\n    \t\t\tattr_dev(h41, \"class\", \"svelte-1nzdlje\");\n    \t\t\tadd_location(h41, file, 56, 8, 1110);\n    \t\t\tattr_dev(legend2, \"class\", \"svelte-1nzdlje\");\n    \t\t\tadd_location(legend2, file, 57, 8, 1136);\n    \t\t\tattr_dev(h42, \"class\", \"svelte-1nzdlje\");\n    \t\t\tadd_location(h42, file, 58, 8, 1168);\n    \t\t\tattr_dev(div, \"class\", \"card svelte-1nzdlje\");\n    \t\t\tadd_location(div, file, 52, 4, 992);\n    \t\t\tattr_dev(main, \"class\", \"svelte-1nzdlje\");\n    \t\t\tadd_location(main, file, 49, 0, 944);\n    \t\t},\n    \t\tm: function mount(target, anchor) {\n    \t\t\tinsert_hydration_dev(target, main, anchor);\n    \t\t\tappend_hydration_dev(main, h1);\n    \t\t\tappend_hydration_dev(h1, t0);\n    \t\t\tappend_hydration_dev(main, t1);\n    \t\t\tappend_hydration_dev(main, div);\n    \t\t\tappend_hydration_dev(div, legend0);\n    \t\t\tappend_hydration_dev(legend0, t2);\n    \t\t\tappend_hydration_dev(div, t3);\n    \t\t\tappend_hydration_dev(div, h40);\n    \t\t\tappend_hydration_dev(h40, t4);\n    \t\t\tappend_hydration_dev(div, t5);\n    \t\t\tappend_hydration_dev(div, legend1);\n    \t\t\tappend_hydration_dev(legend1, t6);\n    \t\t\tappend_hydration_dev(div, t7);\n    \t\t\tappend_hydration_dev(div, h41);\n    \t\t\tappend_hydration_dev(h41, t8);\n    \t\t\tappend_hydration_dev(div, t9);\n    \t\t\tappend_hydration_dev(div, legend2);\n    \t\t\tappend_hydration_dev(legend2, t10);\n    \t\t\tappend_hydration_dev(div, t11);\n    \t\t\tappend_hydration_dev(div, h42);\n    \t\t\tappend_hydration_dev(h42, t12);\n    \t\t},\n    \t\tp: noop,\n    \t\ti: noop,\n    \t\to: noop,\n    \t\td: function destroy(detaching) {\n    \t\t\tif (detaching) detach_dev(main);\n    \t\t}\n    \t};\n\n    \tdispatch_dev(\"SvelteRegisterBlock\", {\n    \t\tblock,\n    \t\tid: create_fragment.name,\n    \t\ttype: \"component\",\n    \t\tsource: \"\",\n    \t\tctx\n    \t});\n\n    \treturn block;\n    }\n\n    function instance($$self, $$props, $$invalidate) {\n    \tlet { $$slots: slots = {}, $$scope } = $$props;\n    \tvalidate_slots('Routes', slots, []);\n    \tlet { gameIdeaObj } = $$props;\n    \tlet style = gameIdeaObj.style;\n    \tlet theme = gameIdeaObj.theme;\n    \tlet genre = gameIdeaObj.genre;\n    \tconst writable_props = ['gameIdeaObj'];\n\n    \tObject.keys($$props).forEach(key => {\n    \t\tif (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Routes> was created with unknown prop '${key}'`);\n    \t});\n\n    \t$$self.$$set = $$props => {\n    \t\tif ('gameIdeaObj' in $$props) $$invalidate(3, gameIdeaObj = $$props.gameIdeaObj);\n    \t};\n\n    \t$$self.$capture_state = () => ({ gameIdeaObj, style, theme, genre });\n\n    \t$$self.$inject_state = $$props => {\n    \t\tif ('gameIdeaObj' in $$props) $$invalidate(3, gameIdeaObj = $$props.gameIdeaObj);\n    \t\tif ('style' in $$props) $$invalidate(0, style = $$props.style);\n    \t\tif ('theme' in $$props) $$invalidate(1, theme = $$props.theme);\n    \t\tif ('genre' in $$props) $$invalidate(2, genre = $$props.genre);\n    \t};\n\n    \tif ($$props && \"$$inject\" in $$props) {\n    \t\t$$self.$inject_state($$props.$$inject);\n    \t}\n\n    \treturn [style, theme, genre, gameIdeaObj];\n    }\n\n    class Routes extends SvelteComponentDev {\n    \tconstructor(options) {\n    \t\tsuper(options);\n    \t\tinit(this, options, instance, create_fragment, safe_not_equal, { gameIdeaObj: 3 });\n\n    \t\tdispatch_dev(\"SvelteRegisterComponent\", {\n    \t\t\tcomponent: this,\n    \t\t\ttagName: \"Routes\",\n    \t\t\toptions,\n    \t\t\tid: create_fragment.name\n    \t\t});\n\n    \t\tconst { ctx } = this.$$;\n    \t\tconst props = options.props || {};\n\n    \t\tif (/*gameIdeaObj*/ ctx[3] === undefined && !('gameIdeaObj' in props)) {\n    \t\t\tconsole.warn(\"<Routes> was created without expected prop 'gameIdeaObj'\");\n    \t\t}\n    \t}\n\n    \tget gameIdeaObj() {\n    \t\tthrow new Error(\"<Routes>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n    \t}\n\n    \tset gameIdeaObj(value) {\n    \t\tthrow new Error(\"<Routes>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n    \t}\n    }",
                    "originalLength": 1516,
                    "removedExports": [],
                    "renderedExports": [
                        "default"
                    ],
                    "renderedLength": 6718
                }
            },
            "name": "index",
            "type": "chunk",
            "code": "var Index = (function () {\n    'use strict';\n\n    function noop() { }\n    function add_location(element, file, line, column, char) {\n        element.__svelte_meta = {\n            loc: { file, line, column, char }\n        };\n    }\n    function run(fn) {\n        return fn();\n    }\n    function blank_object() {\n        return Object.create(null);\n    }\n    function run_all(fns) {\n        fns.forEach(run);\n    }\n    function is_function(thing) {\n        return typeof thing === 'function';\n    }\n    function safe_not_equal(a, b) {\n        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');\n    }\n    function is_empty(obj) {\n        return Object.keys(obj).length === 0;\n    }\n\n    // Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM\n    // at the end of hydration without touching the remaining nodes.\n    let is_hydrating = false;\n    function start_hydrating() {\n        is_hydrating = true;\n    }\n    function end_hydrating() {\n        is_hydrating = false;\n    }\n    function upper_bound(low, high, key, value) {\n        // Return first index of value larger than input value in the range [low, high)\n        while (low < high) {\n            const mid = low + ((high - low) >> 1);\n            if (key(mid) <= value) {\n                low = mid + 1;\n            }\n            else {\n                high = mid;\n            }\n        }\n        return low;\n    }\n    function init_hydrate(target) {\n        if (target.hydrate_init)\n            return;\n        target.hydrate_init = true;\n        // We know that all children have claim_order values since the unclaimed have been detached if target is not <head>\n        let children = target.childNodes;\n        // If target is <head>, there may be children without claim_order\n        if (target.nodeName === 'HEAD') {\n            const myChildren = [];\n            for (let i = 0; i < children.length; i++) {\n                const node = children[i];\n                if (node.claim_order !== undefined) {\n                    myChildren.push(node);\n                }\n            }\n            children = myChildren;\n        }\n        /*\n        * Reorder claimed children optimally.\n        * We can reorder claimed children optimally by finding the longest subsequence of\n        * nodes that are already claimed in order and only moving the rest. The longest\n        * subsequence subsequence of nodes that are claimed in order can be found by\n        * computing the longest increasing subsequence of .claim_order values.\n        *\n        * This algorithm is optimal in generating the least amount of reorder operations\n        * possible.\n        *\n        * Proof:\n        * We know that, given a set of reordering operations, the nodes that do not move\n        * always form an increasing subsequence, since they do not move among each other\n        * meaning that they must be already ordered among each other. Thus, the maximal\n        * set of nodes that do not move form a longest increasing subsequence.\n        */\n        // Compute longest increasing subsequence\n        // m: subsequence length j => index k of smallest value that ends an increasing subsequence of length j\n        const m = new Int32Array(children.length + 1);\n        // Predecessor indices + 1\n        const p = new Int32Array(children.length);\n        m[0] = -1;\n        let longest = 0;\n        for (let i = 0; i < children.length; i++) {\n            const current = children[i].claim_order;\n            // Find the largest subsequence length such that it ends in a value less than our current value\n            // upper_bound returns first greater value, so we subtract one\n            // with fast path for when we are on the current longest subsequence\n            const seqLen = ((longest > 0 && children[m[longest]].claim_order <= current) ? longest + 1 : upper_bound(1, longest, idx => children[m[idx]].claim_order, current)) - 1;\n            p[i] = m[seqLen] + 1;\n            const newLen = seqLen + 1;\n            // We can guarantee that current is the smallest value. Otherwise, we would have generated a longer sequence.\n            m[newLen] = i;\n            longest = Math.max(newLen, longest);\n        }\n        // The longest increasing subsequence of nodes (initially reversed)\n        const lis = [];\n        // The rest of the nodes, nodes that will be moved\n        const toMove = [];\n        let last = children.length - 1;\n        for (let cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {\n            lis.push(children[cur - 1]);\n            for (; last >= cur; last--) {\n                toMove.push(children[last]);\n            }\n            last--;\n        }\n        for (; last >= 0; last--) {\n            toMove.push(children[last]);\n        }\n        lis.reverse();\n        // We sort the nodes being moved to guarantee that their insertion order matches the claim order\n        toMove.sort((a, b) => a.claim_order - b.claim_order);\n        // Finally, we move the nodes\n        for (let i = 0, j = 0; i < toMove.length; i++) {\n            while (j < lis.length && toMove[i].claim_order >= lis[j].claim_order) {\n                j++;\n            }\n            const anchor = j < lis.length ? lis[j] : null;\n            target.insertBefore(toMove[i], anchor);\n        }\n    }\n    function append_hydration(target, node) {\n        if (is_hydrating) {\n            init_hydrate(target);\n            if ((target.actual_end_child === undefined) || ((target.actual_end_child !== null) && (target.actual_end_child.parentElement !== target))) {\n                target.actual_end_child = target.firstChild;\n            }\n            // Skip nodes of undefined ordering\n            while ((target.actual_end_child !== null) && (target.actual_end_child.claim_order === undefined)) {\n                target.actual_end_child = target.actual_end_child.nextSibling;\n            }\n            if (node !== target.actual_end_child) {\n                // We only insert if the ordering of this node should be modified or the parent node is not target\n                if (node.claim_order !== undefined || node.parentNode !== target) {\n                    target.insertBefore(node, target.actual_end_child);\n                }\n            }\n            else {\n                target.actual_end_child = node.nextSibling;\n            }\n        }\n        else if (node.parentNode !== target || node.nextSibling !== null) {\n            target.appendChild(node);\n        }\n    }\n    function insert_hydration(target, node, anchor) {\n        if (is_hydrating && !anchor) {\n            append_hydration(target, node);\n        }\n        else if (node.parentNode !== target || node.nextSibling != anchor) {\n            target.insertBefore(node, anchor || null);\n        }\n    }\n    function detach(node) {\n        node.parentNode.removeChild(node);\n    }\n    function element(name) {\n        return document.createElement(name);\n    }\n    function text(data) {\n        return document.createTextNode(data);\n    }\n    function space() {\n        return text(' ');\n    }\n    function attr(node, attribute, value) {\n        if (value == null)\n            node.removeAttribute(attribute);\n        else if (node.getAttribute(attribute) !== value)\n            node.setAttribute(attribute, value);\n    }\n    function children(element) {\n        return Array.from(element.childNodes);\n    }\n    function init_claim_info(nodes) {\n        if (nodes.claim_info === undefined) {\n            nodes.claim_info = { last_index: 0, total_claimed: 0 };\n        }\n    }\n    function claim_node(nodes, predicate, processNode, createNode, dontUpdateLastIndex = false) {\n        // Try to find nodes in an order such that we lengthen the longest increasing subsequence\n        init_claim_info(nodes);\n        const resultNode = (() => {\n            // We first try to find an element after the previous one\n            for (let i = nodes.claim_info.last_index; i < nodes.length; i++) {\n                const node = nodes[i];\n                if (predicate(node)) {\n                    const replacement = processNode(node);\n                    if (replacement === undefined) {\n                        nodes.splice(i, 1);\n                    }\n                    else {\n                        nodes[i] = replacement;\n                    }\n                    if (!dontUpdateLastIndex) {\n                        nodes.claim_info.last_index = i;\n                    }\n                    return node;\n                }\n            }\n            // Otherwise, we try to find one before\n            // We iterate in reverse so that we don't go too far back\n            for (let i = nodes.claim_info.last_index - 1; i >= 0; i--) {\n                const node = nodes[i];\n                if (predicate(node)) {\n                    const replacement = processNode(node);\n                    if (replacement === undefined) {\n                        nodes.splice(i, 1);\n                    }\n                    else {\n                        nodes[i] = replacement;\n                    }\n                    if (!dontUpdateLastIndex) {\n                        nodes.claim_info.last_index = i;\n                    }\n                    else if (replacement === undefined) {\n                        // Since we spliced before the last_index, we decrease it\n                        nodes.claim_info.last_index--;\n                    }\n                    return node;\n                }\n            }\n            // If we can't find any matching node, we create a new one\n            return createNode();\n        })();\n        resultNode.claim_order = nodes.claim_info.total_claimed;\n        nodes.claim_info.total_claimed += 1;\n        return resultNode;\n    }\n    function claim_element_base(nodes, name, attributes, create_element) {\n        return claim_node(nodes, (node) => node.nodeName === name, (node) => {\n            const remove = [];\n            for (let j = 0; j < node.attributes.length; j++) {\n                const attribute = node.attributes[j];\n                if (!attributes[attribute.name]) {\n                    remove.push(attribute.name);\n                }\n            }\n            remove.forEach(v => node.removeAttribute(v));\n            return undefined;\n        }, () => create_element(name));\n    }\n    function claim_element(nodes, name, attributes) {\n        return claim_element_base(nodes, name, attributes, element);\n    }\n    function claim_text(nodes, data) {\n        return claim_node(nodes, (node) => node.nodeType === 3, (node) => {\n            const dataStr = '' + data;\n            if (node.data.startsWith(dataStr)) {\n                if (node.data.length !== dataStr.length) {\n                    return node.splitText(dataStr.length);\n                }\n            }\n            else {\n                node.data = dataStr;\n            }\n        }, () => text(data), true // Text nodes should not update last index since it is likely not worth it to eliminate an increasing subsequence of actual elements\n        );\n    }\n    function claim_space(nodes) {\n        return claim_text(nodes, ' ');\n    }\n    function custom_event(type, detail, bubbles = false) {\n        const e = document.createEvent('CustomEvent');\n        e.initCustomEvent(type, bubbles, false, detail);\n        return e;\n    }\n\n    let current_component;\n    function set_current_component(component) {\n        current_component = component;\n    }\n\n    const dirty_components = [];\n    const binding_callbacks = [];\n    const render_callbacks = [];\n    const flush_callbacks = [];\n    const resolved_promise = Promise.resolve();\n    let update_scheduled = false;\n    function schedule_update() {\n        if (!update_scheduled) {\n            update_scheduled = true;\n            resolved_promise.then(flush);\n        }\n    }\n    function add_render_callback(fn) {\n        render_callbacks.push(fn);\n    }\n    let flushing = false;\n    const seen_callbacks = new Set();\n    function flush() {\n        if (flushing)\n            return;\n        flushing = true;\n        do {\n            // first, call beforeUpdate functions\n            // and update components\n            for (let i = 0; i < dirty_components.length; i += 1) {\n                const component = dirty_components[i];\n                set_current_component(component);\n                update(component.$$);\n            }\n            set_current_component(null);\n            dirty_components.length = 0;\n            while (binding_callbacks.length)\n                binding_callbacks.pop()();\n            // then, once components are updated, call\n            // afterUpdate functions. This may cause\n            // subsequent updates...\n            for (let i = 0; i < render_callbacks.length; i += 1) {\n                const callback = render_callbacks[i];\n                if (!seen_callbacks.has(callback)) {\n                    // ...so guard against infinite loops\n                    seen_callbacks.add(callback);\n                    callback();\n                }\n            }\n            render_callbacks.length = 0;\n        } while (dirty_components.length);\n        while (flush_callbacks.length) {\n            flush_callbacks.pop()();\n        }\n        update_scheduled = false;\n        flushing = false;\n        seen_callbacks.clear();\n    }\n    function update($$) {\n        if ($$.fragment !== null) {\n            $$.update();\n            run_all($$.before_update);\n            const dirty = $$.dirty;\n            $$.dirty = [-1];\n            $$.fragment && $$.fragment.p($$.ctx, dirty);\n            $$.after_update.forEach(add_render_callback);\n        }\n    }\n    const outroing = new Set();\n    function transition_in(block, local) {\n        if (block && block.i) {\n            outroing.delete(block);\n            block.i(local);\n        }\n    }\n    function mount_component(component, target, anchor, customElement) {\n        const { fragment, on_mount, on_destroy, after_update } = component.$$;\n        fragment && fragment.m(target, anchor);\n        if (!customElement) {\n            // onMount happens before the initial afterUpdate\n            add_render_callback(() => {\n                const new_on_destroy = on_mount.map(run).filter(is_function);\n                if (on_destroy) {\n                    on_destroy.push(...new_on_destroy);\n                }\n                else {\n                    // Edge case - component was destroyed immediately,\n                    // most likely as a result of a binding initialising\n                    run_all(new_on_destroy);\n                }\n                component.$$.on_mount = [];\n            });\n        }\n        after_update.forEach(add_render_callback);\n    }\n    function destroy_component(component, detaching) {\n        const $$ = component.$$;\n        if ($$.fragment !== null) {\n            run_all($$.on_destroy);\n            $$.fragment && $$.fragment.d(detaching);\n            // TODO null out other refs, including component.$$ (but need to\n            // preserve final state?)\n            $$.on_destroy = $$.fragment = null;\n            $$.ctx = [];\n        }\n    }\n    function make_dirty(component, i) {\n        if (component.$$.dirty[0] === -1) {\n            dirty_components.push(component);\n            schedule_update();\n            component.$$.dirty.fill(0);\n        }\n        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));\n    }\n    function init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {\n        const parent_component = current_component;\n        set_current_component(component);\n        const $$ = component.$$ = {\n            fragment: null,\n            ctx: null,\n            // state\n            props,\n            update: noop,\n            not_equal,\n            bound: blank_object(),\n            // lifecycle\n            on_mount: [],\n            on_destroy: [],\n            on_disconnect: [],\n            before_update: [],\n            after_update: [],\n            context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n            // everything else\n            callbacks: blank_object(),\n            dirty,\n            skip_bound: false,\n            root: options.target || parent_component.$$.root\n        };\n        append_styles && append_styles($$.root);\n        let ready = false;\n        $$.ctx = instance\n            ? instance(component, options.props || {}, (i, ret, ...rest) => {\n                const value = rest.length ? rest[0] : ret;\n                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n                    if (!$$.skip_bound && $$.bound[i])\n                        $$.bound[i](value);\n                    if (ready)\n                        make_dirty(component, i);\n                }\n                return ret;\n            })\n            : [];\n        $$.update();\n        ready = true;\n        run_all($$.before_update);\n        // `false` as a special case of no DOM component\n        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n        if (options.target) {\n            if (options.hydrate) {\n                start_hydrating();\n                const nodes = children(options.target);\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                $$.fragment && $$.fragment.l(nodes);\n                nodes.forEach(detach);\n            }\n            else {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                $$.fragment && $$.fragment.c();\n            }\n            if (options.intro)\n                transition_in(component.$$.fragment);\n            mount_component(component, options.target, options.anchor, options.customElement);\n            end_hydrating();\n            flush();\n        }\n        set_current_component(parent_component);\n    }\n    /**\n     * Base class for Svelte components. Used when dev=false.\n     */\n    class SvelteComponent {\n        $destroy() {\n            destroy_component(this, 1);\n            this.$destroy = noop;\n        }\n        $on(type, callback) {\n            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n            callbacks.push(callback);\n            return () => {\n                const index = callbacks.indexOf(callback);\n                if (index !== -1)\n                    callbacks.splice(index, 1);\n            };\n        }\n        $set($$props) {\n            if (this.$$set && !is_empty($$props)) {\n                this.$$.skip_bound = true;\n                this.$$set($$props);\n                this.$$.skip_bound = false;\n            }\n        }\n    }\n\n    function dispatch_dev(type, detail) {\n        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.44.1' }, detail), true));\n    }\n    function append_hydration_dev(target, node) {\n        dispatch_dev('SvelteDOMInsert', { target, node });\n        append_hydration(target, node);\n    }\n    function insert_hydration_dev(target, node, anchor) {\n        dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n        insert_hydration(target, node, anchor);\n    }\n    function detach_dev(node) {\n        dispatch_dev('SvelteDOMRemove', { node });\n        detach(node);\n    }\n    function attr_dev(node, attribute, value) {\n        attr(node, attribute, value);\n        if (value == null)\n            dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });\n        else\n            dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });\n    }\n    function validate_slots(name, slot, keys) {\n        for (const slot_key of Object.keys(slot)) {\n            if (!~keys.indexOf(slot_key)) {\n                console.warn(`<${name}> received an unexpected slot \"${slot_key}\".`);\n            }\n        }\n    }\n    /**\n     * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.\n     */\n    class SvelteComponentDev extends SvelteComponent {\n        constructor(options) {\n            if (!options || (!options.target && !options.$$inline)) {\n                throw new Error(\"'target' is a required option\");\n            }\n            super();\n        }\n        $destroy() {\n            super.$destroy();\n            this.$destroy = () => {\n                console.warn('Component was already destroyed'); // eslint-disable-line no-console\n            };\n        }\n        $capture_state() { }\n        $inject_state() { }\n    }\n\n    /* src\\routes\\index.svelte generated by Svelte v3.44.1 */\n\n    const file = \"src\\\\routes\\\\index.svelte\";\n\n    function create_fragment(ctx) {\n    \tlet main;\n    \tlet h1;\n    \tlet t0;\n    \tlet t1;\n    \tlet div;\n    \tlet legend0;\n    \tlet t2;\n    \tlet t3;\n    \tlet h40;\n    \tlet t4;\n    \tlet t5;\n    \tlet legend1;\n    \tlet t6;\n    \tlet t7;\n    \tlet h41;\n    \tlet t8;\n    \tlet t9;\n    \tlet legend2;\n    \tlet t10;\n    \tlet t11;\n    \tlet h42;\n    \tlet t12;\n\n    \tconst block = {\n    \t\tc: function create() {\n    \t\t\tmain = element(\"main\");\n    \t\t\th1 = element(\"h1\");\n    \t\t\tt0 = text(\"Game Idea Generator\");\n    \t\t\tt1 = space();\n    \t\t\tdiv = element(\"div\");\n    \t\t\tlegend0 = element(\"legend\");\n    \t\t\tt2 = text(\"STYLE\");\n    \t\t\tt3 = space();\n    \t\t\th40 = element(\"h4\");\n    \t\t\tt4 = text(/*style*/ ctx[0]);\n    \t\t\tt5 = space();\n    \t\t\tlegend1 = element(\"legend\");\n    \t\t\tt6 = text(\"THEME\");\n    \t\t\tt7 = space();\n    \t\t\th41 = element(\"h4\");\n    \t\t\tt8 = text(/*theme*/ ctx[1]);\n    \t\t\tt9 = space();\n    \t\t\tlegend2 = element(\"legend\");\n    \t\t\tt10 = text(\"GENRE\");\n    \t\t\tt11 = space();\n    \t\t\th42 = element(\"h4\");\n    \t\t\tt12 = text(/*genre*/ ctx[2]);\n    \t\t\tthis.h();\n    \t\t},\n    \t\tl: function claim(nodes) {\n    \t\t\tmain = claim_element(nodes, \"MAIN\", { class: true });\n    \t\t\tvar main_nodes = children(main);\n    \t\t\th1 = claim_element(main_nodes, \"H1\", { class: true });\n    \t\t\tvar h1_nodes = children(h1);\n    \t\t\tt0 = claim_text(h1_nodes, \"Game Idea Generator\");\n    \t\t\th1_nodes.forEach(detach_dev);\n    \t\t\tt1 = claim_space(main_nodes);\n    \t\t\tdiv = claim_element(main_nodes, \"DIV\", { class: true });\n    \t\t\tvar div_nodes = children(div);\n    \t\t\tlegend0 = claim_element(div_nodes, \"LEGEND\", { class: true });\n    \t\t\tvar legend0_nodes = children(legend0);\n    \t\t\tt2 = claim_text(legend0_nodes, \"STYLE\");\n    \t\t\tlegend0_nodes.forEach(detach_dev);\n    \t\t\tt3 = claim_space(div_nodes);\n    \t\t\th40 = claim_element(div_nodes, \"H4\", { class: true });\n    \t\t\tvar h40_nodes = children(h40);\n    \t\t\tt4 = claim_text(h40_nodes, /*style*/ ctx[0]);\n    \t\t\th40_nodes.forEach(detach_dev);\n    \t\t\tt5 = claim_space(div_nodes);\n    \t\t\tlegend1 = claim_element(div_nodes, \"LEGEND\", { class: true });\n    \t\t\tvar legend1_nodes = children(legend1);\n    \t\t\tt6 = claim_text(legend1_nodes, \"THEME\");\n    \t\t\tlegend1_nodes.forEach(detach_dev);\n    \t\t\tt7 = claim_space(div_nodes);\n    \t\t\th41 = claim_element(div_nodes, \"H4\", { class: true });\n    \t\t\tvar h41_nodes = children(h41);\n    \t\t\tt8 = claim_text(h41_nodes, /*theme*/ ctx[1]);\n    \t\t\th41_nodes.forEach(detach_dev);\n    \t\t\tt9 = claim_space(div_nodes);\n    \t\t\tlegend2 = claim_element(div_nodes, \"LEGEND\", { class: true });\n    \t\t\tvar legend2_nodes = children(legend2);\n    \t\t\tt10 = claim_text(legend2_nodes, \"GENRE\");\n    \t\t\tlegend2_nodes.forEach(detach_dev);\n    \t\t\tt11 = claim_space(div_nodes);\n    \t\t\th42 = claim_element(div_nodes, \"H4\", { class: true });\n    \t\t\tvar h42_nodes = children(h42);\n    \t\t\tt12 = claim_text(h42_nodes, /*genre*/ ctx[2]);\n    \t\t\th42_nodes.forEach(detach_dev);\n    \t\t\tdiv_nodes.forEach(detach_dev);\n    \t\t\tmain_nodes.forEach(detach_dev);\n    \t\t\tthis.h();\n    \t\t},\n    \t\th: function hydrate() {\n    \t\t\tattr_dev(h1, \"class\", \"svelte-1nzdlje\");\n    \t\t\tadd_location(h1, file, 50, 4, 956);\n    \t\t\tattr_dev(legend0, \"class\", \"svelte-1nzdlje\");\n    \t\t\tadd_location(legend0, file, 53, 8, 1020);\n    \t\t\tattr_dev(h40, \"class\", \"svelte-1nzdlje\");\n    \t\t\tadd_location(h40, file, 54, 8, 1052);\n    \t\t\tattr_dev(legend1, \"class\", \"svelte-1nzdlje\");\n    \t\t\tadd_location(legend1, file, 55, 8, 1078);\n    \t\t\tattr_dev(h41, \"class\", \"svelte-1nzdlje\");\n    \t\t\tadd_location(h41, file, 56, 8, 1110);\n    \t\t\tattr_dev(legend2, \"class\", \"svelte-1nzdlje\");\n    \t\t\tadd_location(legend2, file, 57, 8, 1136);\n    \t\t\tattr_dev(h42, \"class\", \"svelte-1nzdlje\");\n    \t\t\tadd_location(h42, file, 58, 8, 1168);\n    \t\t\tattr_dev(div, \"class\", \"card svelte-1nzdlje\");\n    \t\t\tadd_location(div, file, 52, 4, 992);\n    \t\t\tattr_dev(main, \"class\", \"svelte-1nzdlje\");\n    \t\t\tadd_location(main, file, 49, 0, 944);\n    \t\t},\n    \t\tm: function mount(target, anchor) {\n    \t\t\tinsert_hydration_dev(target, main, anchor);\n    \t\t\tappend_hydration_dev(main, h1);\n    \t\t\tappend_hydration_dev(h1, t0);\n    \t\t\tappend_hydration_dev(main, t1);\n    \t\t\tappend_hydration_dev(main, div);\n    \t\t\tappend_hydration_dev(div, legend0);\n    \t\t\tappend_hydration_dev(legend0, t2);\n    \t\t\tappend_hydration_dev(div, t3);\n    \t\t\tappend_hydration_dev(div, h40);\n    \t\t\tappend_hydration_dev(h40, t4);\n    \t\t\tappend_hydration_dev(div, t5);\n    \t\t\tappend_hydration_dev(div, legend1);\n    \t\t\tappend_hydration_dev(legend1, t6);\n    \t\t\tappend_hydration_dev(div, t7);\n    \t\t\tappend_hydration_dev(div, h41);\n    \t\t\tappend_hydration_dev(h41, t8);\n    \t\t\tappend_hydration_dev(div, t9);\n    \t\t\tappend_hydration_dev(div, legend2);\n    \t\t\tappend_hydration_dev(legend2, t10);\n    \t\t\tappend_hydration_dev(div, t11);\n    \t\t\tappend_hydration_dev(div, h42);\n    \t\t\tappend_hydration_dev(h42, t12);\n    \t\t},\n    \t\tp: noop,\n    \t\ti: noop,\n    \t\to: noop,\n    \t\td: function destroy(detaching) {\n    \t\t\tif (detaching) detach_dev(main);\n    \t\t}\n    \t};\n\n    \tdispatch_dev(\"SvelteRegisterBlock\", {\n    \t\tblock,\n    \t\tid: create_fragment.name,\n    \t\ttype: \"component\",\n    \t\tsource: \"\",\n    \t\tctx\n    \t});\n\n    \treturn block;\n    }\n\n    function instance($$self, $$props, $$invalidate) {\n    \tlet { $$slots: slots = {}, $$scope } = $$props;\n    \tvalidate_slots('Routes', slots, []);\n    \tlet { gameIdeaObj } = $$props;\n    \tlet style = gameIdeaObj.style;\n    \tlet theme = gameIdeaObj.theme;\n    \tlet genre = gameIdeaObj.genre;\n    \tconst writable_props = ['gameIdeaObj'];\n\n    \tObject.keys($$props).forEach(key => {\n    \t\tif (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Routes> was created with unknown prop '${key}'`);\n    \t});\n\n    \t$$self.$$set = $$props => {\n    \t\tif ('gameIdeaObj' in $$props) $$invalidate(3, gameIdeaObj = $$props.gameIdeaObj);\n    \t};\n\n    \t$$self.$capture_state = () => ({ gameIdeaObj, style, theme, genre });\n\n    \t$$self.$inject_state = $$props => {\n    \t\tif ('gameIdeaObj' in $$props) $$invalidate(3, gameIdeaObj = $$props.gameIdeaObj);\n    \t\tif ('style' in $$props) $$invalidate(0, style = $$props.style);\n    \t\tif ('theme' in $$props) $$invalidate(1, theme = $$props.theme);\n    \t\tif ('genre' in $$props) $$invalidate(2, genre = $$props.genre);\n    \t};\n\n    \tif ($$props && \"$$inject\" in $$props) {\n    \t\t$$self.$inject_state($$props.$$inject);\n    \t}\n\n    \treturn [style, theme, genre, gameIdeaObj];\n    }\n\n    class Routes extends SvelteComponentDev {\n    \tconstructor(options) {\n    \t\tsuper(options);\n    \t\tinit(this, options, instance, create_fragment, safe_not_equal, { gameIdeaObj: 3 });\n\n    \t\tdispatch_dev(\"SvelteRegisterComponent\", {\n    \t\t\tcomponent: this,\n    \t\t\ttagName: \"Routes\",\n    \t\t\toptions,\n    \t\t\tid: create_fragment.name\n    \t\t});\n\n    \t\tconst { ctx } = this.$$;\n    \t\tconst props = options.props || {};\n\n    \t\tif (/*gameIdeaObj*/ ctx[3] === undefined && !('gameIdeaObj' in props)) {\n    \t\t\tconsole.warn(\"<Routes> was created without expected prop 'gameIdeaObj'\");\n    \t\t}\n    \t}\n\n    \tget gameIdeaObj() {\n    \t\tthrow new Error(\"<Routes>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n    \t}\n\n    \tset gameIdeaObj(value) {\n    \t\tthrow new Error(\"<Routes>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n    \t}\n    }\n\n    return Routes;\n\n})();\n",
            "dynamicImports": [],
            "fileName": "index.js",
            "implicitlyLoadedBefore": [],
            "importedBindings": {},
            "imports": [],
            "map": null,
            "referencedFiles": []
        },
        "watchFiles": [
            "C:\\Users\\ignur\\Desktop\\Portfolio\\gameidea-generator\\src\\routes\\index.svelte",
            "C:\\Users\\ignur\\Desktop\\Portfolio\\gameidea-generator\\src\\routes\\index.css",
            "C:\\Users\\ignur\\Desktop\\Portfolio\\gameidea-generator\\node_modules\\svelte\\internal\\index.mjs"
        ]
    },
    "hashes": {
        "js": "e39e23136b91ec6e0c7f4c66aaf6a3d2",
        "css": "410455bed6e71110f39caee444f5cf17"
    }
}