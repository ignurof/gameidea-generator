{
    "server": {
        "component": "'use strict';\n\nfunction run(fn) {\n    return fn();\n}\nfunction blank_object() {\n    return Object.create(null);\n}\nfunction run_all(fns) {\n    fns.forEach(run);\n}\n\nlet current_component;\nfunction set_current_component(component) {\n    current_component = component;\n}\nPromise.resolve();\nconst escaped = {\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;'\n};\nfunction escape(html) {\n    return String(html).replace(/[\"'&<>]/g, match => escaped[match]);\n}\nlet on_destroy;\nfunction create_ssr_component(fn) {\n    function $$render(result, props, bindings, slots, context) {\n        const parent_component = current_component;\n        const $$ = {\n            on_destroy,\n            context: new Map(context || (parent_component ? parent_component.$$.context : [])),\n            // these will be immediately discarded\n            on_mount: [],\n            before_update: [],\n            after_update: [],\n            callbacks: blank_object()\n        };\n        set_current_component({ $$ });\n        const html = fn(result, props, bindings, slots);\n        set_current_component(parent_component);\n        return html;\n    }\n    return {\n        render: (props = {}, { $$slots = {}, context = new Map() } = {}) => {\n            on_destroy = [];\n            const result = { title: '', head: '', css: new Set() };\n            const html = $$render(result, props, {}, $$slots, context);\n            run_all(on_destroy);\n            return {\n                html,\n                css: {\n                    code: Array.from(result.css).map(css => css.code).join('\\n'),\n                    map: null // TODO\n                },\n                head: result.title + result.head\n            };\n        },\n        $$render\n    };\n}\n\n/* src\\routes\\index.svelte generated by Svelte v3.44.1 */\n\nconst css = {\n\tcode: \"main.svelte-11rvpx5.svelte-11rvpx5{color:#f2f4f7;text-align:center;font-size:16px;overflow:hidden}h1.svelte-11rvpx5.svelte-11rvpx5{color:#facb49;text-shadow:0px 4px 4px #7c2323;margin-top:3em}button.svelte-11rvpx5.svelte-11rvpx5{margin:4em;border:0;border-radius:0.6em;background:#d85c3d;color:white;font-size:1.6em;font-weight:bold;padding:1em;cursor:pointer;transition:0.4s}button.svelte-11rvpx5.svelte-11rvpx5:hover{box-shadow:-4px 4px 0px #e29885, 4px 4px 0px #e29885, -4px -4px 0px #e29885, 4px -4px 0px #e29885}.card.svelte-11rvpx5.svelte-11rvpx5{color:#141414;margin-top:6em;margin-left:auto;margin-right:auto;border:0;border-radius:0.6em;background:#f0f0f0;width:18em;box-shadow:2px 8px 4px rgba(0, 0, 0, 0.24), -2px 8px 4px rgba(0, 0, 0, 0.24);padding-top:1em;padding-bottom:1em}legend.svelte-11rvpx5.svelte-11rvpx5{color:#655f68;font-size:1em;font-family:Impact, Haettenschweiler, \\\"Arial Narrow Bold\\\", sans-serif;margin-left:auto}.field.svelte-11rvpx5.svelte-11rvpx5{display:flex;flex-direction:row}svg.svelte-11rvpx5.svelte-11rvpx5{width:1em;margin-bottom:1.4em;margin-left:0.6em;margin-right:6em;fill:#65778d;cursor:pointer}#closed-lock.svelte-11rvpx5.svelte-11rvpx5{fill:red}h4.svelte-11rvpx5.svelte-11rvpx5{margin:0;margin-top:0.4em;margin-bottom:1.6em;font-size:1.4em;font-family:\\\"Gill Sans\\\", \\\"Gill Sans MT\\\", Calibri, \\\"Trebuchet MS\\\", sans-serif;text-shadow:2px 4px 4px #b8b8b8}footer.svelte-11rvpx5.svelte-11rvpx5{background:#385a5a;position:absolute;bottom:0;width:100%;padding-bottom:2em}footer.svelte-11rvpx5 a.svelte-11rvpx5{text-decoration:none;color:white}.credits.svelte-11rvpx5.svelte-11rvpx5{padding-top:2em}\",\n\tmap: \"{\\\"version\\\":3,\\\"file\\\":\\\"index.svelte\\\",\\\"sources\\\":[\\\"index.svelte\\\"],\\\"sourcesContent\\\":[\\\"<script>\\\\r\\\\n    export let gameIdeaObj;\\\\r\\\\n\\\\r\\\\n    let style = gameIdeaObj.style;\\\\r\\\\n    let theme = gameIdeaObj.theme;\\\\r\\\\n    let genre = gameIdeaObj.genre;\\\\r\\\\n\\\\r\\\\n    let styleLock = false;\\\\r\\\\n    let themeLock = false;\\\\r\\\\n    let genreLock = false;\\\\r\\\\n\\\\r\\\\n    let styleTempField;\\\\r\\\\n    let themeTempField;\\\\r\\\\n    let genreTempField;\\\\r\\\\n\\\\r\\\\n    // Request idea object from backend\\\\r\\\\n    const FetchNewIdea = async() => {\\\\r\\\\n        let response = await fetch(\\\\\\\"/generate\\\\\\\");\\\\r\\\\n\\\\r\\\\n        if(!response.ok) return console.error(\\\\\\\"Something went wrong with generate request!\\\\\\\");\\\\r\\\\n\\\\r\\\\n        let result = await response.json();\\\\r\\\\n\\\\r\\\\n        style = result.style;\\\\r\\\\n        theme = result.theme;\\\\r\\\\n        genre = result.genre;\\\\r\\\\n    }\\\\r\\\\n\\\\r\\\\n    // Change lock and update fields accordingly\\\\r\\\\n    const ChangeLockStatus = (fieldType) => {\\\\r\\\\n        if(fieldType === \\\\\\\"style\\\\\\\"){\\\\r\\\\n            if(!styleLock){\\\\r\\\\n                styleTempField = style;\\\\r\\\\n            } else style = styleTempField;\\\\r\\\\n            styleLock = !styleLock;\\\\r\\\\n        }\\\\r\\\\n        if(fieldType === \\\\\\\"theme\\\\\\\"){\\\\r\\\\n            if(!themeLock){\\\\r\\\\n                themeTempField = theme;\\\\r\\\\n            } else theme = themeTempField;\\\\r\\\\n            themeLock = !themeLock;\\\\r\\\\n        }\\\\r\\\\n        if(fieldType === \\\\\\\"genre\\\\\\\"){\\\\r\\\\n            if(!genreLock){\\\\r\\\\n                genreTempField = genre;\\\\r\\\\n            } else genre = genreTempField;\\\\r\\\\n            genreLock = !genreLock;\\\\r\\\\n        }\\\\r\\\\n    }\\\\r\\\\n</script>\\\\r\\\\n\\\\r\\\\n<style>main {\\\\n  color: #f2f4f7;\\\\n  text-align: center;\\\\n  font-size: 16px;\\\\n  overflow: hidden;\\\\n}\\\\n\\\\nh1 {\\\\n  color: #facb49;\\\\n  text-shadow: 0px 4px 4px #7c2323;\\\\n  margin-top: 3em;\\\\n}\\\\n\\\\nbutton {\\\\n  margin: 4em;\\\\n  border: 0;\\\\n  border-radius: 0.6em;\\\\n  background: #d85c3d;\\\\n  color: white;\\\\n  font-size: 1.6em;\\\\n  font-weight: bold;\\\\n  padding: 1em;\\\\n  cursor: pointer;\\\\n  transition: 0.4s;\\\\n}\\\\n\\\\nbutton:hover {\\\\n  box-shadow: -4px 4px 0px #e29885, 4px 4px 0px #e29885, -4px -4px 0px #e29885, 4px -4px 0px #e29885;\\\\n}\\\\n\\\\n.card {\\\\n  color: #141414;\\\\n  margin-top: 6em;\\\\n  margin-left: auto;\\\\n  margin-right: auto;\\\\n  border: 0;\\\\n  border-radius: 0.6em;\\\\n  background: #f0f0f0;\\\\n  width: 18em;\\\\n  box-shadow: 2px 8px 4px rgba(0, 0, 0, 0.24), -2px 8px 4px rgba(0, 0, 0, 0.24);\\\\n  padding-top: 1em;\\\\n  padding-bottom: 1em;\\\\n}\\\\n\\\\nlegend {\\\\n  color: #655f68;\\\\n  font-size: 1em;\\\\n  font-family: Impact, Haettenschweiler, \\\\\\\"Arial Narrow Bold\\\\\\\", sans-serif;\\\\n  margin-left: auto;\\\\n}\\\\n\\\\n.field {\\\\n  display: flex;\\\\n  flex-direction: row;\\\\n}\\\\n\\\\nsvg {\\\\n  width: 1em;\\\\n  margin-bottom: 1.4em;\\\\n  margin-left: 0.6em;\\\\n  margin-right: 6em;\\\\n  fill: #65778d;\\\\n  cursor: pointer;\\\\n}\\\\n\\\\n#closed-lock {\\\\n  fill: red;\\\\n}\\\\n\\\\nh4 {\\\\n  margin: 0;\\\\n  margin-top: 0.4em;\\\\n  margin-bottom: 1.6em;\\\\n  font-size: 1.4em;\\\\n  font-family: \\\\\\\"Gill Sans\\\\\\\", \\\\\\\"Gill Sans MT\\\\\\\", Calibri, \\\\\\\"Trebuchet MS\\\\\\\", sans-serif;\\\\n  text-shadow: 2px 4px 4px #b8b8b8;\\\\n}\\\\n\\\\nfooter {\\\\n  background: #385a5a;\\\\n  position: absolute;\\\\n  bottom: 0;\\\\n  width: 100%;\\\\n  padding-bottom: 2em;\\\\n}\\\\n\\\\nfooter a {\\\\n  text-decoration: none;\\\\n  color: white;\\\\n}\\\\n\\\\n.credits {\\\\n  padding-top: 2em;\\\\n}</style>\\\\r\\\\n\\\\r\\\\n<main>\\\\r\\\\n    <h1>Game Idea Generator</h1>\\\\r\\\\n\\\\r\\\\n    <div class=\\\\\\\"card\\\\\\\">\\\\r\\\\n\\\\r\\\\n        <div class=\\\\\\\"field\\\\\\\">\\\\r\\\\n            <legend>STYLE</legend>\\\\r\\\\n            {#if !styleLock}\\\\r\\\\n                <svg xmlns=\\\\\\\"http://www.w3.org/2000/svg\\\\\\\" class=\\\\\\\"h-5 w-5\\\\\\\" viewBox=\\\\\\\"0 0 20 20\\\\\\\" fill=\\\\\\\"currentColor\\\\\\\" on:click={() => ChangeLockStatus(\\\\\\\"style\\\\\\\")}>\\\\r\\\\n                    <path d=\\\\\\\"M10 2a5 5 0 00-5 5v2a2 2 0 00-2 2v5a2 2 0 002 2h10a2 2 0 002-2v-5a2 2 0 00-2-2H7V7a3 3 0 015.905-.75 1 1 0 001.937-.5A5.002 5.002 0 0010 2z\\\\\\\" />\\\\r\\\\n                </svg>\\\\r\\\\n            {:else}\\\\r\\\\n                <svg id=\\\\\\\"closed-lock\\\\\\\" xmlns=\\\\\\\"http://www.w3.org/2000/svg\\\\\\\" class=\\\\\\\"h-5 w-5\\\\\\\" viewBox=\\\\\\\"0 0 20 20\\\\\\\" fill=\\\\\\\"currentColor\\\\\\\" on:click={() => ChangeLockStatus(\\\\\\\"style\\\\\\\")}>\\\\r\\\\n                    <path fill-rule=\\\\\\\"evenodd\\\\\\\" d=\\\\\\\"M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z\\\\\\\" clip-rule=\\\\\\\"evenodd\\\\\\\" />\\\\r\\\\n                </svg>\\\\r\\\\n            {/if}\\\\r\\\\n        </div>\\\\r\\\\n        {#if !styleLock}\\\\r\\\\n            <h4>{style}</h4>\\\\r\\\\n        {:else}\\\\r\\\\n            <h4>{styleTempField}</h4>\\\\r\\\\n        {/if}\\\\r\\\\n\\\\r\\\\n        <div class=\\\\\\\"field\\\\\\\">\\\\r\\\\n            <legend>THEME</legend>\\\\r\\\\n            {#if !themeLock}\\\\r\\\\n                <svg xmlns=\\\\\\\"http://www.w3.org/2000/svg\\\\\\\" class=\\\\\\\"h-5 w-5\\\\\\\" viewBox=\\\\\\\"0 0 20 20\\\\\\\" fill=\\\\\\\"currentColor\\\\\\\" on:click={() => ChangeLockStatus(\\\\\\\"theme\\\\\\\")}>\\\\r\\\\n                    <path d=\\\\\\\"M10 2a5 5 0 00-5 5v2a2 2 0 00-2 2v5a2 2 0 002 2h10a2 2 0 002-2v-5a2 2 0 00-2-2H7V7a3 3 0 015.905-.75 1 1 0 001.937-.5A5.002 5.002 0 0010 2z\\\\\\\" />\\\\r\\\\n                </svg>\\\\r\\\\n            {:else}\\\\r\\\\n                <svg id=\\\\\\\"closed-lock\\\\\\\" xmlns=\\\\\\\"http://www.w3.org/2000/svg\\\\\\\" class=\\\\\\\"h-5 w-5\\\\\\\" viewBox=\\\\\\\"0 0 20 20\\\\\\\" fill=\\\\\\\"currentColor\\\\\\\" on:click={() => ChangeLockStatus(\\\\\\\"theme\\\\\\\")}>\\\\r\\\\n                    <path fill-rule=\\\\\\\"evenodd\\\\\\\" d=\\\\\\\"M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z\\\\\\\" clip-rule=\\\\\\\"evenodd\\\\\\\" />\\\\r\\\\n                </svg>\\\\r\\\\n            {/if}\\\\r\\\\n        </div>\\\\r\\\\n        {#if !themeLock}\\\\r\\\\n            <h4>{theme}</h4>\\\\r\\\\n        {:else}\\\\r\\\\n            <h4>{themeTempField}</h4>\\\\r\\\\n        {/if}\\\\r\\\\n        <div class=\\\\\\\"field\\\\\\\">\\\\r\\\\n            <legend>GENRE</legend>\\\\r\\\\n            {#if !genreLock}\\\\r\\\\n                <svg xmlns=\\\\\\\"http://www.w3.org/2000/svg\\\\\\\" class=\\\\\\\"h-5 w-5\\\\\\\" viewBox=\\\\\\\"0 0 20 20\\\\\\\" fill=\\\\\\\"currentColor\\\\\\\" on:click={() => ChangeLockStatus(\\\\\\\"genre\\\\\\\")}>\\\\r\\\\n                    <path d=\\\\\\\"M10 2a5 5 0 00-5 5v2a2 2 0 00-2 2v5a2 2 0 002 2h10a2 2 0 002-2v-5a2 2 0 00-2-2H7V7a3 3 0 015.905-.75 1 1 0 001.937-.5A5.002 5.002 0 0010 2z\\\\\\\" />\\\\r\\\\n                </svg>\\\\r\\\\n            {:else}\\\\r\\\\n                <svg id=\\\\\\\"closed-lock\\\\\\\" xmlns=\\\\\\\"http://www.w3.org/2000/svg\\\\\\\" class=\\\\\\\"h-5 w-5\\\\\\\" viewBox=\\\\\\\"0 0 20 20\\\\\\\" fill=\\\\\\\"currentColor\\\\\\\" on:click={() => ChangeLockStatus(\\\\\\\"genre\\\\\\\")}>\\\\r\\\\n                    <path fill-rule=\\\\\\\"evenodd\\\\\\\" d=\\\\\\\"M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z\\\\\\\" clip-rule=\\\\\\\"evenodd\\\\\\\" />\\\\r\\\\n                </svg>\\\\r\\\\n            {/if}\\\\r\\\\n        </div>\\\\r\\\\n        {#if !genreLock}\\\\r\\\\n            <h4>{genre}</h4>\\\\r\\\\n        {:else}\\\\r\\\\n            <h4>{genreTempField}</h4>\\\\r\\\\n        {/if}\\\\r\\\\n            \\\\r\\\\n    </div>\\\\r\\\\n\\\\r\\\\n    <button on:click={() => FetchNewIdea()}>GENERATE</button>\\\\r\\\\n\\\\r\\\\n    <footer>\\\\r\\\\n        <div class=\\\\\\\"credits\\\\\\\">\\\\r\\\\n            Copyright 2021 - <a href=\\\\\\\"ignurof.xyz\\\\\\\" target=\\\\\\\"_blank\\\\\\\">ignurof.xyz</a>\\\\r\\\\n        </div>\\\\r\\\\n    </footer>\\\\r\\\\n</main>\\\\r\\\\n\\\\r\\\\n\\\"],\\\"names\\\":[],\\\"mappings\\\":\\\"AAmDO,IAAI,8BAAC,CAAC,AACX,KAAK,CAAE,OAAO,CACd,UAAU,CAAE,MAAM,CAClB,SAAS,CAAE,IAAI,CACf,QAAQ,CAAE,MAAM,AAClB,CAAC,AAED,EAAE,8BAAC,CAAC,AACF,KAAK,CAAE,OAAO,CACd,WAAW,CAAE,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,OAAO,CAChC,UAAU,CAAE,GAAG,AACjB,CAAC,AAED,MAAM,8BAAC,CAAC,AACN,MAAM,CAAE,GAAG,CACX,MAAM,CAAE,CAAC,CACT,aAAa,CAAE,KAAK,CACpB,UAAU,CAAE,OAAO,CACnB,KAAK,CAAE,KAAK,CACZ,SAAS,CAAE,KAAK,CAChB,WAAW,CAAE,IAAI,CACjB,OAAO,CAAE,GAAG,CACZ,MAAM,CAAE,OAAO,CACf,UAAU,CAAE,IAAI,AAClB,CAAC,AAED,oCAAM,MAAM,AAAC,CAAC,AACZ,UAAU,CAAE,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,OAAO,AACpG,CAAC,AAED,KAAK,8BAAC,CAAC,AACL,KAAK,CAAE,OAAO,CACd,UAAU,CAAE,GAAG,CACf,WAAW,CAAE,IAAI,CACjB,YAAY,CAAE,IAAI,CAClB,MAAM,CAAE,CAAC,CACT,aAAa,CAAE,KAAK,CACpB,UAAU,CAAE,OAAO,CACnB,KAAK,CAAE,IAAI,CACX,UAAU,CAAE,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAC7E,WAAW,CAAE,GAAG,CAChB,cAAc,CAAE,GAAG,AACrB,CAAC,AAED,MAAM,8BAAC,CAAC,AACN,KAAK,CAAE,OAAO,CACd,SAAS,CAAE,GAAG,CACd,WAAW,CAAE,MAAM,CAAC,CAAC,gBAAgB,CAAC,CAAC,mBAAmB,CAAC,CAAC,UAAU,CACtE,WAAW,CAAE,IAAI,AACnB,CAAC,AAED,MAAM,8BAAC,CAAC,AACN,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,GAAG,AACrB,CAAC,AAED,GAAG,8BAAC,CAAC,AACH,KAAK,CAAE,GAAG,CACV,aAAa,CAAE,KAAK,CACpB,WAAW,CAAE,KAAK,CAClB,YAAY,CAAE,GAAG,CACjB,IAAI,CAAE,OAAO,CACb,MAAM,CAAE,OAAO,AACjB,CAAC,AAED,YAAY,8BAAC,CAAC,AACZ,IAAI,CAAE,GAAG,AACX,CAAC,AAED,EAAE,8BAAC,CAAC,AACF,MAAM,CAAE,CAAC,CACT,UAAU,CAAE,KAAK,CACjB,aAAa,CAAE,KAAK,CACpB,SAAS,CAAE,KAAK,CAChB,WAAW,CAAE,WAAW,CAAC,CAAC,cAAc,CAAC,CAAC,OAAO,CAAC,CAAC,cAAc,CAAC,CAAC,UAAU,CAC7E,WAAW,CAAE,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,OAAO,AAClC,CAAC,AAED,MAAM,8BAAC,CAAC,AACN,UAAU,CAAE,OAAO,CACnB,QAAQ,CAAE,QAAQ,CAClB,MAAM,CAAE,CAAC,CACT,KAAK,CAAE,IAAI,CACX,cAAc,CAAE,GAAG,AACrB,CAAC,AAED,qBAAM,CAAC,CAAC,eAAC,CAAC,AACR,eAAe,CAAE,IAAI,CACrB,KAAK,CAAE,KAAK,AACd,CAAC,AAED,QAAQ,8BAAC,CAAC,AACR,WAAW,CAAE,GAAG,AAClB,CAAC\\\"}\"\n};\n\nconst Routes = create_ssr_component(($$result, $$props, $$bindings, slots) => {\n\tlet { gameIdeaObj } = $$props;\n\tlet style = gameIdeaObj.style;\n\tlet theme = gameIdeaObj.theme;\n\tlet genre = gameIdeaObj.genre;\n\n\tif ($$props.gameIdeaObj === void 0 && $$bindings.gameIdeaObj && gameIdeaObj !== void 0) $$bindings.gameIdeaObj(gameIdeaObj);\n\t$$result.css.add(css);\n\n\treturn `<main class=\"${\"svelte-11rvpx5\"}\"><h1 class=\"${\"svelte-11rvpx5\"}\">Game Idea Generator</h1>\r\n\r\n    <div class=\"${\"card svelte-11rvpx5\"}\"><div class=\"${\"field svelte-11rvpx5\"}\"><legend class=\"${\"svelte-11rvpx5\"}\">STYLE</legend>\r\n            ${`<svg xmlns=\"${\"http://www.w3.org/2000/svg\"}\" class=\"${\"h-5 w-5 svelte-11rvpx5\"}\" viewBox=\"${\"0 0 20 20\"}\" fill=\"${\"currentColor\"}\"><path d=\"${\"M10 2a5 5 0 00-5 5v2a2 2 0 00-2 2v5a2 2 0 002 2h10a2 2 0 002-2v-5a2 2 0 00-2-2H7V7a3 3 0 015.905-.75 1 1 0 001.937-.5A5.002 5.002 0 0010 2z\"}\"></path></svg>`\n\t}</div>\r\n        ${`<h4 class=\"${\"svelte-11rvpx5\"}\">${escape(style)}</h4>`\n\t}\r\n\r\n        <div class=\"${\"field svelte-11rvpx5\"}\"><legend class=\"${\"svelte-11rvpx5\"}\">THEME</legend>\r\n            ${`<svg xmlns=\"${\"http://www.w3.org/2000/svg\"}\" class=\"${\"h-5 w-5 svelte-11rvpx5\"}\" viewBox=\"${\"0 0 20 20\"}\" fill=\"${\"currentColor\"}\"><path d=\"${\"M10 2a5 5 0 00-5 5v2a2 2 0 00-2 2v5a2 2 0 002 2h10a2 2 0 002-2v-5a2 2 0 00-2-2H7V7a3 3 0 015.905-.75 1 1 0 001.937-.5A5.002 5.002 0 0010 2z\"}\"></path></svg>`\n\t}</div>\r\n        ${`<h4 class=\"${\"svelte-11rvpx5\"}\">${escape(theme)}</h4>`\n\t}\r\n        <div class=\"${\"field svelte-11rvpx5\"}\"><legend class=\"${\"svelte-11rvpx5\"}\">GENRE</legend>\r\n            ${`<svg xmlns=\"${\"http://www.w3.org/2000/svg\"}\" class=\"${\"h-5 w-5 svelte-11rvpx5\"}\" viewBox=\"${\"0 0 20 20\"}\" fill=\"${\"currentColor\"}\"><path d=\"${\"M10 2a5 5 0 00-5 5v2a2 2 0 00-2 2v5a2 2 0 002 2h10a2 2 0 002-2v-5a2 2 0 00-2-2H7V7a3 3 0 015.905-.75 1 1 0 001.937-.5A5.002 5.002 0 0010 2z\"}\"></path></svg>`\n\t}</div>\r\n        ${`<h4 class=\"${\"svelte-11rvpx5\"}\">${escape(genre)}</h4>`\n\t}</div>\r\n\r\n    <button class=\"${\"svelte-11rvpx5\"}\">GENERATE</button>\r\n\r\n    <footer class=\"${\"svelte-11rvpx5\"}\"><div class=\"${\"credits svelte-11rvpx5\"}\">Copyright 2021 - <a href=\"${\"ignurof.xyz\"}\" target=\"${\"_blank\"}\" class=\"${\"svelte-11rvpx5\"}\">ignurof.xyz</a></div></footer></main>`;\n});\n\nmodule.exports = Routes;\n",
        "css": "main.svelte-11rvpx5.svelte-11rvpx5{color:#f2f4f7;text-align:center;font-size:16px;overflow:hidden}h1.svelte-11rvpx5.svelte-11rvpx5{color:#facb49;text-shadow:0px 4px 4px #7c2323;margin-top:3em}button.svelte-11rvpx5.svelte-11rvpx5{margin:4em;border:0;border-radius:0.6em;background:#d85c3d;color:white;font-size:1.6em;font-weight:bold;padding:1em;cursor:pointer;transition:0.4s}button.svelte-11rvpx5.svelte-11rvpx5:hover{box-shadow:-4px 4px 0px #e29885, 4px 4px 0px #e29885, -4px -4px 0px #e29885, 4px -4px 0px #e29885}.card.svelte-11rvpx5.svelte-11rvpx5{color:#141414;margin-top:6em;margin-left:auto;margin-right:auto;border:0;border-radius:0.6em;background:#f0f0f0;width:18em;box-shadow:2px 8px 4px rgba(0, 0, 0, 0.24), -2px 8px 4px rgba(0, 0, 0, 0.24);padding-top:1em;padding-bottom:1em}legend.svelte-11rvpx5.svelte-11rvpx5{color:#655f68;font-size:1em;font-family:Impact, Haettenschweiler, \"Arial Narrow Bold\", sans-serif;margin-left:auto}.field.svelte-11rvpx5.svelte-11rvpx5{display:flex;flex-direction:row}svg.svelte-11rvpx5.svelte-11rvpx5{width:1em;margin-bottom:1.4em;margin-left:0.6em;margin-right:6em;fill:#65778d;cursor:pointer}#closed-lock.svelte-11rvpx5.svelte-11rvpx5{fill:red}h4.svelte-11rvpx5.svelte-11rvpx5{margin:0;margin-top:0.4em;margin-bottom:1.6em;font-size:1.4em;font-family:\"Gill Sans\", \"Gill Sans MT\", Calibri, \"Trebuchet MS\", sans-serif;text-shadow:2px 4px 4px #b8b8b8}footer.svelte-11rvpx5.svelte-11rvpx5{background:#385a5a;position:absolute;bottom:0;width:100%;padding-bottom:2em}footer.svelte-11rvpx5 a.svelte-11rvpx5{text-decoration:none;color:white}.credits.svelte-11rvpx5.svelte-11rvpx5{padding-top:2em}"
    },
    "client": {
        "js": {
            "exports": [
                "default"
            ],
            "facadeModuleId": "C:\\Users\\ignur\\Desktop\\Portfolio\\gameidea-generator\\src\\routes\\index.svelte",
            "isDynamicEntry": false,
            "isEntry": true,
            "isImplicitEntry": false,
            "modules": {
                "C:\\Users\\ignur\\Desktop\\Portfolio\\gameidea-generator\\node_modules\\svelte\\internal\\index.mjs": {
                    "code": "    function noop() { }\n    function add_location(element, file, line, column, char) {\n        element.__svelte_meta = {\n            loc: { file, line, column, char }\n        };\n    }\n    function run(fn) {\n        return fn();\n    }\n    function blank_object() {\n        return Object.create(null);\n    }\n    function run_all(fns) {\n        fns.forEach(run);\n    }\n    function is_function(thing) {\n        return typeof thing === 'function';\n    }\n    function safe_not_equal(a, b) {\n        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');\n    }\n    function is_empty(obj) {\n        return Object.keys(obj).length === 0;\n    }\n\n    // Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM\n    // at the end of hydration without touching the remaining nodes.\n    let is_hydrating = false;\n    function start_hydrating() {\n        is_hydrating = true;\n    }\n    function end_hydrating() {\n        is_hydrating = false;\n    }\n    function upper_bound(low, high, key, value) {\n        // Return first index of value larger than input value in the range [low, high)\n        while (low < high) {\n            const mid = low + ((high - low) >> 1);\n            if (key(mid) <= value) {\n                low = mid + 1;\n            }\n            else {\n                high = mid;\n            }\n        }\n        return low;\n    }\n    function init_hydrate(target) {\n        if (target.hydrate_init)\n            return;\n        target.hydrate_init = true;\n        // We know that all children have claim_order values since the unclaimed have been detached if target is not <head>\n        let children = target.childNodes;\n        // If target is <head>, there may be children without claim_order\n        if (target.nodeName === 'HEAD') {\n            const myChildren = [];\n            for (let i = 0; i < children.length; i++) {\n                const node = children[i];\n                if (node.claim_order !== undefined) {\n                    myChildren.push(node);\n                }\n            }\n            children = myChildren;\n        }\n        /*\n        * Reorder claimed children optimally.\n        * We can reorder claimed children optimally by finding the longest subsequence of\n        * nodes that are already claimed in order and only moving the rest. The longest\n        * subsequence subsequence of nodes that are claimed in order can be found by\n        * computing the longest increasing subsequence of .claim_order values.\n        *\n        * This algorithm is optimal in generating the least amount of reorder operations\n        * possible.\n        *\n        * Proof:\n        * We know that, given a set of reordering operations, the nodes that do not move\n        * always form an increasing subsequence, since they do not move among each other\n        * meaning that they must be already ordered among each other. Thus, the maximal\n        * set of nodes that do not move form a longest increasing subsequence.\n        */\n        // Compute longest increasing subsequence\n        // m: subsequence length j => index k of smallest value that ends an increasing subsequence of length j\n        const m = new Int32Array(children.length + 1);\n        // Predecessor indices + 1\n        const p = new Int32Array(children.length);\n        m[0] = -1;\n        let longest = 0;\n        for (let i = 0; i < children.length; i++) {\n            const current = children[i].claim_order;\n            // Find the largest subsequence length such that it ends in a value less than our current value\n            // upper_bound returns first greater value, so we subtract one\n            // with fast path for when we are on the current longest subsequence\n            const seqLen = ((longest > 0 && children[m[longest]].claim_order <= current) ? longest + 1 : upper_bound(1, longest, idx => children[m[idx]].claim_order, current)) - 1;\n            p[i] = m[seqLen] + 1;\n            const newLen = seqLen + 1;\n            // We can guarantee that current is the smallest value. Otherwise, we would have generated a longer sequence.\n            m[newLen] = i;\n            longest = Math.max(newLen, longest);\n        }\n        // The longest increasing subsequence of nodes (initially reversed)\n        const lis = [];\n        // The rest of the nodes, nodes that will be moved\n        const toMove = [];\n        let last = children.length - 1;\n        for (let cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {\n            lis.push(children[cur - 1]);\n            for (; last >= cur; last--) {\n                toMove.push(children[last]);\n            }\n            last--;\n        }\n        for (; last >= 0; last--) {\n            toMove.push(children[last]);\n        }\n        lis.reverse();\n        // We sort the nodes being moved to guarantee that their insertion order matches the claim order\n        toMove.sort((a, b) => a.claim_order - b.claim_order);\n        // Finally, we move the nodes\n        for (let i = 0, j = 0; i < toMove.length; i++) {\n            while (j < lis.length && toMove[i].claim_order >= lis[j].claim_order) {\n                j++;\n            }\n            const anchor = j < lis.length ? lis[j] : null;\n            target.insertBefore(toMove[i], anchor);\n        }\n    }\n    function append_hydration(target, node) {\n        if (is_hydrating) {\n            init_hydrate(target);\n            if ((target.actual_end_child === undefined) || ((target.actual_end_child !== null) && (target.actual_end_child.parentElement !== target))) {\n                target.actual_end_child = target.firstChild;\n            }\n            // Skip nodes of undefined ordering\n            while ((target.actual_end_child !== null) && (target.actual_end_child.claim_order === undefined)) {\n                target.actual_end_child = target.actual_end_child.nextSibling;\n            }\n            if (node !== target.actual_end_child) {\n                // We only insert if the ordering of this node should be modified or the parent node is not target\n                if (node.claim_order !== undefined || node.parentNode !== target) {\n                    target.insertBefore(node, target.actual_end_child);\n                }\n            }\n            else {\n                target.actual_end_child = node.nextSibling;\n            }\n        }\n        else if (node.parentNode !== target || node.nextSibling !== null) {\n            target.appendChild(node);\n        }\n    }\n    function insert_hydration(target, node, anchor) {\n        if (is_hydrating && !anchor) {\n            append_hydration(target, node);\n        }\n        else if (node.parentNode !== target || node.nextSibling != anchor) {\n            target.insertBefore(node, anchor || null);\n        }\n    }\n    function detach(node) {\n        node.parentNode.removeChild(node);\n    }\n    function element(name) {\n        return document.createElement(name);\n    }\n    function svg_element(name) {\n        return document.createElementNS('http://www.w3.org/2000/svg', name);\n    }\n    function text(data) {\n        return document.createTextNode(data);\n    }\n    function space() {\n        return text(' ');\n    }\n    function listen(node, event, handler, options) {\n        node.addEventListener(event, handler, options);\n        return () => node.removeEventListener(event, handler, options);\n    }\n    function attr(node, attribute, value) {\n        if (value == null)\n            node.removeAttribute(attribute);\n        else if (node.getAttribute(attribute) !== value)\n            node.setAttribute(attribute, value);\n    }\n    function children(element) {\n        return Array.from(element.childNodes);\n    }\n    function init_claim_info(nodes) {\n        if (nodes.claim_info === undefined) {\n            nodes.claim_info = { last_index: 0, total_claimed: 0 };\n        }\n    }\n    function claim_node(nodes, predicate, processNode, createNode, dontUpdateLastIndex = false) {\n        // Try to find nodes in an order such that we lengthen the longest increasing subsequence\n        init_claim_info(nodes);\n        const resultNode = (() => {\n            // We first try to find an element after the previous one\n            for (let i = nodes.claim_info.last_index; i < nodes.length; i++) {\n                const node = nodes[i];\n                if (predicate(node)) {\n                    const replacement = processNode(node);\n                    if (replacement === undefined) {\n                        nodes.splice(i, 1);\n                    }\n                    else {\n                        nodes[i] = replacement;\n                    }\n                    if (!dontUpdateLastIndex) {\n                        nodes.claim_info.last_index = i;\n                    }\n                    return node;\n                }\n            }\n            // Otherwise, we try to find one before\n            // We iterate in reverse so that we don't go too far back\n            for (let i = nodes.claim_info.last_index - 1; i >= 0; i--) {\n                const node = nodes[i];\n                if (predicate(node)) {\n                    const replacement = processNode(node);\n                    if (replacement === undefined) {\n                        nodes.splice(i, 1);\n                    }\n                    else {\n                        nodes[i] = replacement;\n                    }\n                    if (!dontUpdateLastIndex) {\n                        nodes.claim_info.last_index = i;\n                    }\n                    else if (replacement === undefined) {\n                        // Since we spliced before the last_index, we decrease it\n                        nodes.claim_info.last_index--;\n                    }\n                    return node;\n                }\n            }\n            // If we can't find any matching node, we create a new one\n            return createNode();\n        })();\n        resultNode.claim_order = nodes.claim_info.total_claimed;\n        nodes.claim_info.total_claimed += 1;\n        return resultNode;\n    }\n    function claim_element_base(nodes, name, attributes, create_element) {\n        return claim_node(nodes, (node) => node.nodeName === name, (node) => {\n            const remove = [];\n            for (let j = 0; j < node.attributes.length; j++) {\n                const attribute = node.attributes[j];\n                if (!attributes[attribute.name]) {\n                    remove.push(attribute.name);\n                }\n            }\n            remove.forEach(v => node.removeAttribute(v));\n            return undefined;\n        }, () => create_element(name));\n    }\n    function claim_element(nodes, name, attributes) {\n        return claim_element_base(nodes, name, attributes, element);\n    }\n    function claim_svg_element(nodes, name, attributes) {\n        return claim_element_base(nodes, name, attributes, svg_element);\n    }\n    function claim_text(nodes, data) {\n        return claim_node(nodes, (node) => node.nodeType === 3, (node) => {\n            const dataStr = '' + data;\n            if (node.data.startsWith(dataStr)) {\n                if (node.data.length !== dataStr.length) {\n                    return node.splitText(dataStr.length);\n                }\n            }\n            else {\n                node.data = dataStr;\n            }\n        }, () => text(data), true // Text nodes should not update last index since it is likely not worth it to eliminate an increasing subsequence of actual elements\n        );\n    }\n    function claim_space(nodes) {\n        return claim_text(nodes, ' ');\n    }\n    function custom_event(type, detail, bubbles = false) {\n        const e = document.createEvent('CustomEvent');\n        e.initCustomEvent(type, bubbles, false, detail);\n        return e;\n    }\n\n    let current_component;\n    function set_current_component(component) {\n        current_component = component;\n    }\n\n    const dirty_components = [];\n    const binding_callbacks = [];\n    const render_callbacks = [];\n    const flush_callbacks = [];\n    const resolved_promise = Promise.resolve();\n    let update_scheduled = false;\n    function schedule_update() {\n        if (!update_scheduled) {\n            update_scheduled = true;\n            resolved_promise.then(flush);\n        }\n    }\n    function add_render_callback(fn) {\n        render_callbacks.push(fn);\n    }\n    let flushing = false;\n    const seen_callbacks = new Set();\n    function flush() {\n        if (flushing)\n            return;\n        flushing = true;\n        do {\n            // first, call beforeUpdate functions\n            // and update components\n            for (let i = 0; i < dirty_components.length; i += 1) {\n                const component = dirty_components[i];\n                set_current_component(component);\n                update(component.$$);\n            }\n            set_current_component(null);\n            dirty_components.length = 0;\n            while (binding_callbacks.length)\n                binding_callbacks.pop()();\n            // then, once components are updated, call\n            // afterUpdate functions. This may cause\n            // subsequent updates...\n            for (let i = 0; i < render_callbacks.length; i += 1) {\n                const callback = render_callbacks[i];\n                if (!seen_callbacks.has(callback)) {\n                    // ...so guard against infinite loops\n                    seen_callbacks.add(callback);\n                    callback();\n                }\n            }\n            render_callbacks.length = 0;\n        } while (dirty_components.length);\n        while (flush_callbacks.length) {\n            flush_callbacks.pop()();\n        }\n        update_scheduled = false;\n        flushing = false;\n        seen_callbacks.clear();\n    }\n    function update($$) {\n        if ($$.fragment !== null) {\n            $$.update();\n            run_all($$.before_update);\n            const dirty = $$.dirty;\n            $$.dirty = [-1];\n            $$.fragment && $$.fragment.p($$.ctx, dirty);\n            $$.after_update.forEach(add_render_callback);\n        }\n    }\n    const outroing = new Set();\n    function transition_in(block, local) {\n        if (block && block.i) {\n            outroing.delete(block);\n            block.i(local);\n        }\n    }\n\n    const globals = (typeof window !== 'undefined'\n        ? window\n        : typeof globalThis !== 'undefined'\n            ? globalThis\n            : global);\n    function mount_component(component, target, anchor, customElement) {\n        const { fragment, on_mount, on_destroy, after_update } = component.$$;\n        fragment && fragment.m(target, anchor);\n        if (!customElement) {\n            // onMount happens before the initial afterUpdate\n            add_render_callback(() => {\n                const new_on_destroy = on_mount.map(run).filter(is_function);\n                if (on_destroy) {\n                    on_destroy.push(...new_on_destroy);\n                }\n                else {\n                    // Edge case - component was destroyed immediately,\n                    // most likely as a result of a binding initialising\n                    run_all(new_on_destroy);\n                }\n                component.$$.on_mount = [];\n            });\n        }\n        after_update.forEach(add_render_callback);\n    }\n    function destroy_component(component, detaching) {\n        const $$ = component.$$;\n        if ($$.fragment !== null) {\n            run_all($$.on_destroy);\n            $$.fragment && $$.fragment.d(detaching);\n            // TODO null out other refs, including component.$$ (but need to\n            // preserve final state?)\n            $$.on_destroy = $$.fragment = null;\n            $$.ctx = [];\n        }\n    }\n    function make_dirty(component, i) {\n        if (component.$$.dirty[0] === -1) {\n            dirty_components.push(component);\n            schedule_update();\n            component.$$.dirty.fill(0);\n        }\n        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));\n    }\n    function init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {\n        const parent_component = current_component;\n        set_current_component(component);\n        const $$ = component.$$ = {\n            fragment: null,\n            ctx: null,\n            // state\n            props,\n            update: noop,\n            not_equal,\n            bound: blank_object(),\n            // lifecycle\n            on_mount: [],\n            on_destroy: [],\n            on_disconnect: [],\n            before_update: [],\n            after_update: [],\n            context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n            // everything else\n            callbacks: blank_object(),\n            dirty,\n            skip_bound: false,\n            root: options.target || parent_component.$$.root\n        };\n        append_styles && append_styles($$.root);\n        let ready = false;\n        $$.ctx = instance\n            ? instance(component, options.props || {}, (i, ret, ...rest) => {\n                const value = rest.length ? rest[0] : ret;\n                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n                    if (!$$.skip_bound && $$.bound[i])\n                        $$.bound[i](value);\n                    if (ready)\n                        make_dirty(component, i);\n                }\n                return ret;\n            })\n            : [];\n        $$.update();\n        ready = true;\n        run_all($$.before_update);\n        // `false` as a special case of no DOM component\n        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n        if (options.target) {\n            if (options.hydrate) {\n                start_hydrating();\n                const nodes = children(options.target);\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                $$.fragment && $$.fragment.l(nodes);\n                nodes.forEach(detach);\n            }\n            else {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                $$.fragment && $$.fragment.c();\n            }\n            if (options.intro)\n                transition_in(component.$$.fragment);\n            mount_component(component, options.target, options.anchor, options.customElement);\n            end_hydrating();\n            flush();\n        }\n        set_current_component(parent_component);\n    }\n    /**\n     * Base class for Svelte components. Used when dev=false.\n     */\n    class SvelteComponent {\n        $destroy() {\n            destroy_component(this, 1);\n            this.$destroy = noop;\n        }\n        $on(type, callback) {\n            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n            callbacks.push(callback);\n            return () => {\n                const index = callbacks.indexOf(callback);\n                if (index !== -1)\n                    callbacks.splice(index, 1);\n            };\n        }\n        $set($$props) {\n            if (this.$$set && !is_empty($$props)) {\n                this.$$.skip_bound = true;\n                this.$$set($$props);\n                this.$$.skip_bound = false;\n            }\n        }\n    }\n\n    function dispatch_dev(type, detail) {\n        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.44.1' }, detail), true));\n    }\n    function append_hydration_dev(target, node) {\n        dispatch_dev('SvelteDOMInsert', { target, node });\n        append_hydration(target, node);\n    }\n    function insert_hydration_dev(target, node, anchor) {\n        dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n        insert_hydration(target, node, anchor);\n    }\n    function detach_dev(node) {\n        dispatch_dev('SvelteDOMRemove', { node });\n        detach(node);\n    }\n    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {\n        const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];\n        if (has_prevent_default)\n            modifiers.push('preventDefault');\n        if (has_stop_propagation)\n            modifiers.push('stopPropagation');\n        dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });\n        const dispose = listen(node, event, handler, options);\n        return () => {\n            dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });\n            dispose();\n        };\n    }\n    function attr_dev(node, attribute, value) {\n        attr(node, attribute, value);\n        if (value == null)\n            dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });\n        else\n            dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });\n    }\n    function set_data_dev(text, data) {\n        data = '' + data;\n        if (text.wholeText === data)\n            return;\n        dispatch_dev('SvelteDOMSetData', { node: text, data });\n        text.data = data;\n    }\n    function validate_slots(name, slot, keys) {\n        for (const slot_key of Object.keys(slot)) {\n            if (!~keys.indexOf(slot_key)) {\n                console.warn(`<${name}> received an unexpected slot \"${slot_key}\".`);\n            }\n        }\n    }\n    /**\n     * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.\n     */\n    class SvelteComponentDev extends SvelteComponent {\n        constructor(options) {\n            if (!options || (!options.target && !options.$$inline)) {\n                throw new Error(\"'target' is a required option\");\n            }\n            super();\n        }\n        $destroy() {\n            super.$destroy();\n            this.$destroy = () => {\n                console.warn('Component was already destroyed'); // eslint-disable-line no-console\n            };\n        }\n        $capture_state() { }\n        $inject_state() { }\n    }",
                    "originalLength": 67632,
                    "removedExports": [
                        "HtmlTag",
                        "HtmlTagHydration",
                        "SvelteComponentTyped",
                        "SvelteElement",
                        "action_destroyer",
                        "add_attribute",
                        "add_classes",
                        "add_flush_callback",
                        "add_resize_listener",
                        "add_transform",
                        "afterUpdate",
                        "append",
                        "append_dev",
                        "append_empty_stylesheet",
                        "append_styles",
                        "assign",
                        "attribute_to_object",
                        "beforeUpdate",
                        "bind",
                        "bubble",
                        "check_outros",
                        "claim_component",
                        "claim_html_tag",
                        "clear_loops",
                        "component_subscribe",
                        "compute_rest_props",
                        "compute_slots",
                        "createEventDispatcher",
                        "create_animation",
                        "create_bidirectional_transition",
                        "create_component",
                        "create_in_transition",
                        "create_out_transition",
                        "create_slot",
                        "create_ssr_component",
                        "dataset_dev",
                        "debug",
                        "destroy_block",
                        "destroy_each",
                        "detach_after_dev",
                        "detach_before_dev",
                        "detach_between_dev",
                        "each",
                        "element_is",
                        "empty",
                        "escape",
                        "escape_attribute_value",
                        "escape_object",
                        "escaped",
                        "exclude_internal_props",
                        "fix_and_destroy_block",
                        "fix_and_outro_and_destroy_block",
                        "fix_position",
                        "getAllContexts",
                        "getContext",
                        "get_all_dirty_from_scope",
                        "get_binding_group_value",
                        "get_current_component",
                        "get_custom_elements_slots",
                        "get_root_for_style",
                        "get_slot_changes",
                        "get_spread_object",
                        "get_spread_update",
                        "get_store_value",
                        "group_outros",
                        "handle_promise",
                        "hasContext",
                        "has_prop",
                        "identity",
                        "insert",
                        "insert_dev",
                        "intros",
                        "invalid_attribute_name_character",
                        "is_client",
                        "is_crossorigin",
                        "is_promise",
                        "loop",
                        "loop_guard",
                        "missing_component",
                        "not_equal",
                        "now",
                        "null_to_empty",
                        "object_without_properties",
                        "onDestroy",
                        "onMount",
                        "once",
                        "outro_and_destroy_block",
                        "prevent_default",
                        "prop_dev",
                        "query_selector_all",
                        "raf",
                        "select_multiple_value",
                        "select_option",
                        "select_options",
                        "select_value",
                        "self",
                        "setContext",
                        "set_attributes",
                        "set_custom_element_data",
                        "set_data",
                        "set_input_type",
                        "set_input_value",
                        "set_now",
                        "set_raf",
                        "set_store_value",
                        "set_style",
                        "set_svg_attributes",
                        "spread",
                        "src_url_equal",
                        "stop_propagation",
                        "subscribe",
                        "tick",
                        "time_ranges_to_array",
                        "to_number",
                        "toggle_class",
                        "transition_out",
                        "trusted",
                        "update_await_block_branch",
                        "update_keyed_each",
                        "update_slot",
                        "update_slot_base",
                        "validate_component",
                        "validate_each_argument",
                        "validate_each_keys",
                        "validate_store",
                        "xlink_attr"
                    ],
                    "renderedExports": [
                        "SvelteComponent",
                        "SvelteComponentDev",
                        "add_location",
                        "add_render_callback",
                        "append_hydration",
                        "append_hydration_dev",
                        "attr",
                        "attr_dev",
                        "binding_callbacks",
                        "blank_object",
                        "children",
                        "claim_element",
                        "claim_space",
                        "claim_svg_element",
                        "claim_text",
                        "current_component",
                        "custom_event",
                        "destroy_component",
                        "detach",
                        "detach_dev",
                        "dirty_components",
                        "dispatch_dev",
                        "element",
                        "end_hydrating",
                        "flush",
                        "globals",
                        "init",
                        "insert_hydration",
                        "insert_hydration_dev",
                        "is_empty",
                        "is_function",
                        "listen",
                        "listen_dev",
                        "mount_component",
                        "noop",
                        "run",
                        "run_all",
                        "safe_not_equal",
                        "schedule_update",
                        "set_current_component",
                        "set_data_dev",
                        "space",
                        "start_hydrating",
                        "svg_element",
                        "text",
                        "transition_in",
                        "validate_slots"
                    ],
                    "renderedLength": 19691
                },
                "C:\\Users\\ignur\\Desktop\\Portfolio\\gameidea-generator\\src\\routes\\index.svelte": {
                    "code": "    /* src\\routes\\index.svelte generated by Svelte v3.44.1 */\n\n    const { console: console_1 } = globals;\n    const file = \"src\\\\routes\\\\index.svelte\";\n\n    // (158:12) {:else}\n    function create_else_block_5(ctx) {\n    \tlet svg;\n    \tlet path;\n    \tlet mounted;\n    \tlet dispose;\n\n    \tconst block = {\n    \t\tc: function create() {\n    \t\t\tsvg = svg_element(\"svg\");\n    \t\t\tpath = svg_element(\"path\");\n    \t\t\tthis.h();\n    \t\t},\n    \t\tl: function claim(nodes) {\n    \t\t\tsvg = claim_svg_element(nodes, \"svg\", {\n    \t\t\t\tid: true,\n    \t\t\t\txmlns: true,\n    \t\t\t\tclass: true,\n    \t\t\t\tviewBox: true,\n    \t\t\t\tfill: true\n    \t\t\t});\n\n    \t\t\tvar svg_nodes = children(svg);\n\n    \t\t\tpath = claim_svg_element(svg_nodes, \"path\", {\n    \t\t\t\t\"fill-rule\": true,\n    \t\t\t\td: true,\n    \t\t\t\t\"clip-rule\": true\n    \t\t\t});\n\n    \t\t\tchildren(path).forEach(detach_dev);\n    \t\t\tsvg_nodes.forEach(detach_dev);\n    \t\t\tthis.h();\n    \t\t},\n    \t\th: function hydrate() {\n    \t\t\tattr_dev(path, \"fill-rule\", \"evenodd\");\n    \t\t\tattr_dev(path, \"d\", \"M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z\");\n    \t\t\tattr_dev(path, \"clip-rule\", \"evenodd\");\n    \t\t\tadd_location(path, file, 159, 20, 3686);\n    \t\t\tattr_dev(svg, \"id\", \"closed-lock\");\n    \t\t\tattr_dev(svg, \"xmlns\", \"http://www.w3.org/2000/svg\");\n    \t\t\tattr_dev(svg, \"class\", \"h-5 w-5 svelte-11rvpx5\");\n    \t\t\tattr_dev(svg, \"viewBox\", \"0 0 20 20\");\n    \t\t\tattr_dev(svg, \"fill\", \"currentColor\");\n    \t\t\tadd_location(svg, file, 158, 16, 3508);\n    \t\t},\n    \t\tm: function mount(target, anchor) {\n    \t\t\tinsert_hydration_dev(target, svg, anchor);\n    \t\t\tappend_hydration_dev(svg, path);\n\n    \t\t\tif (!mounted) {\n    \t\t\t\tdispose = listen_dev(svg, \"click\", /*click_handler_1*/ ctx[13], false, false, false);\n    \t\t\t\tmounted = true;\n    \t\t\t}\n    \t\t},\n    \t\tp: noop,\n    \t\td: function destroy(detaching) {\n    \t\t\tif (detaching) detach_dev(svg);\n    \t\t\tmounted = false;\n    \t\t\tdispose();\n    \t\t}\n    \t};\n\n    \tdispatch_dev(\"SvelteRegisterBlock\", {\n    \t\tblock,\n    \t\tid: create_else_block_5.name,\n    \t\ttype: \"else\",\n    \t\tsource: \"(158:12) {:else}\",\n    \t\tctx\n    \t});\n\n    \treturn block;\n    }\n\n    // (154:12) {#if !styleLock}\n    function create_if_block_5(ctx) {\n    \tlet svg;\n    \tlet path;\n    \tlet mounted;\n    \tlet dispose;\n\n    \tconst block = {\n    \t\tc: function create() {\n    \t\t\tsvg = svg_element(\"svg\");\n    \t\t\tpath = svg_element(\"path\");\n    \t\t\tthis.h();\n    \t\t},\n    \t\tl: function claim(nodes) {\n    \t\t\tsvg = claim_svg_element(nodes, \"svg\", {\n    \t\t\t\txmlns: true,\n    \t\t\t\tclass: true,\n    \t\t\t\tviewBox: true,\n    \t\t\t\tfill: true\n    \t\t\t});\n\n    \t\t\tvar svg_nodes = children(svg);\n    \t\t\tpath = claim_svg_element(svg_nodes, \"path\", { d: true });\n    \t\t\tchildren(path).forEach(detach_dev);\n    \t\t\tsvg_nodes.forEach(detach_dev);\n    \t\t\tthis.h();\n    \t\t},\n    \t\th: function hydrate() {\n    \t\t\tattr_dev(path, \"d\", \"M10 2a5 5 0 00-5 5v2a2 2 0 00-2 2v5a2 2 0 002 2h10a2 2 0 002-2v-5a2 2 0 00-2-2H7V7a3 3 0 015.905-.75 1 1 0 001.937-.5A5.002 5.002 0 0010 2z\");\n    \t\t\tadd_location(path, file, 155, 20, 3293);\n    \t\t\tattr_dev(svg, \"xmlns\", \"http://www.w3.org/2000/svg\");\n    \t\t\tattr_dev(svg, \"class\", \"h-5 w-5 svelte-11rvpx5\");\n    \t\t\tattr_dev(svg, \"viewBox\", \"0 0 20 20\");\n    \t\t\tattr_dev(svg, \"fill\", \"currentColor\");\n    \t\t\tadd_location(svg, file, 154, 16, 3132);\n    \t\t},\n    \t\tm: function mount(target, anchor) {\n    \t\t\tinsert_hydration_dev(target, svg, anchor);\n    \t\t\tappend_hydration_dev(svg, path);\n\n    \t\t\tif (!mounted) {\n    \t\t\t\tdispose = listen_dev(svg, \"click\", /*click_handler*/ ctx[12], false, false, false);\n    \t\t\t\tmounted = true;\n    \t\t\t}\n    \t\t},\n    \t\tp: noop,\n    \t\td: function destroy(detaching) {\n    \t\t\tif (detaching) detach_dev(svg);\n    \t\t\tmounted = false;\n    \t\t\tdispose();\n    \t\t}\n    \t};\n\n    \tdispatch_dev(\"SvelteRegisterBlock\", {\n    \t\tblock,\n    \t\tid: create_if_block_5.name,\n    \t\ttype: \"if\",\n    \t\tsource: \"(154:12) {#if !styleLock}\",\n    \t\tctx\n    \t});\n\n    \treturn block;\n    }\n\n    // (166:8) {:else}\n    function create_else_block_4(ctx) {\n    \tlet h4;\n    \tlet t;\n\n    \tconst block = {\n    \t\tc: function create() {\n    \t\t\th4 = element(\"h4\");\n    \t\t\tt = text(/*styleTempField*/ ctx[6]);\n    \t\t\tthis.h();\n    \t\t},\n    \t\tl: function claim(nodes) {\n    \t\t\th4 = claim_element(nodes, \"H4\", { class: true });\n    \t\t\tvar h4_nodes = children(h4);\n    \t\t\tt = claim_text(h4_nodes, /*styleTempField*/ ctx[6]);\n    \t\t\th4_nodes.forEach(detach_dev);\n    \t\t\tthis.h();\n    \t\t},\n    \t\th: function hydrate() {\n    \t\t\tattr_dev(h4, \"class\", \"svelte-11rvpx5\");\n    \t\t\tadd_location(h4, file, 166, 12, 3987);\n    \t\t},\n    \t\tm: function mount(target, anchor) {\n    \t\t\tinsert_hydration_dev(target, h4, anchor);\n    \t\t\tappend_hydration_dev(h4, t);\n    \t\t},\n    \t\tp: function update(ctx, dirty) {\n    \t\t\tif (dirty & /*styleTempField*/ 64) set_data_dev(t, /*styleTempField*/ ctx[6]);\n    \t\t},\n    \t\td: function destroy(detaching) {\n    \t\t\tif (detaching) detach_dev(h4);\n    \t\t}\n    \t};\n\n    \tdispatch_dev(\"SvelteRegisterBlock\", {\n    \t\tblock,\n    \t\tid: create_else_block_4.name,\n    \t\ttype: \"else\",\n    \t\tsource: \"(166:8) {:else}\",\n    \t\tctx\n    \t});\n\n    \treturn block;\n    }\n\n    // (164:8) {#if !styleLock}\n    function create_if_block_4(ctx) {\n    \tlet h4;\n    \tlet t;\n\n    \tconst block = {\n    \t\tc: function create() {\n    \t\t\th4 = element(\"h4\");\n    \t\t\tt = text(/*style*/ ctx[0]);\n    \t\t\tthis.h();\n    \t\t},\n    \t\tl: function claim(nodes) {\n    \t\t\th4 = claim_element(nodes, \"H4\", { class: true });\n    \t\t\tvar h4_nodes = children(h4);\n    \t\t\tt = claim_text(h4_nodes, /*style*/ ctx[0]);\n    \t\t\th4_nodes.forEach(detach_dev);\n    \t\t\tthis.h();\n    \t\t},\n    \t\th: function hydrate() {\n    \t\t\tattr_dev(h4, \"class\", \"svelte-11rvpx5\");\n    \t\t\tadd_location(h4, file, 164, 12, 3940);\n    \t\t},\n    \t\tm: function mount(target, anchor) {\n    \t\t\tinsert_hydration_dev(target, h4, anchor);\n    \t\t\tappend_hydration_dev(h4, t);\n    \t\t},\n    \t\tp: function update(ctx, dirty) {\n    \t\t\tif (dirty & /*style*/ 1) set_data_dev(t, /*style*/ ctx[0]);\n    \t\t},\n    \t\td: function destroy(detaching) {\n    \t\t\tif (detaching) detach_dev(h4);\n    \t\t}\n    \t};\n\n    \tdispatch_dev(\"SvelteRegisterBlock\", {\n    \t\tblock,\n    \t\tid: create_if_block_4.name,\n    \t\ttype: \"if\",\n    \t\tsource: \"(164:8) {#if !styleLock}\",\n    \t\tctx\n    \t});\n\n    \treturn block;\n    }\n\n    // (176:12) {:else}\n    function create_else_block_3(ctx) {\n    \tlet svg;\n    \tlet path;\n    \tlet mounted;\n    \tlet dispose;\n\n    \tconst block = {\n    \t\tc: function create() {\n    \t\t\tsvg = svg_element(\"svg\");\n    \t\t\tpath = svg_element(\"path\");\n    \t\t\tthis.h();\n    \t\t},\n    \t\tl: function claim(nodes) {\n    \t\t\tsvg = claim_svg_element(nodes, \"svg\", {\n    \t\t\t\tid: true,\n    \t\t\t\txmlns: true,\n    \t\t\t\tclass: true,\n    \t\t\t\tviewBox: true,\n    \t\t\t\tfill: true\n    \t\t\t});\n\n    \t\t\tvar svg_nodes = children(svg);\n\n    \t\t\tpath = claim_svg_element(svg_nodes, \"path\", {\n    \t\t\t\t\"fill-rule\": true,\n    \t\t\t\td: true,\n    \t\t\t\t\"clip-rule\": true\n    \t\t\t});\n\n    \t\t\tchildren(path).forEach(detach_dev);\n    \t\t\tsvg_nodes.forEach(detach_dev);\n    \t\t\tthis.h();\n    \t\t},\n    \t\th: function hydrate() {\n    \t\t\tattr_dev(path, \"fill-rule\", \"evenodd\");\n    \t\t\tattr_dev(path, \"d\", \"M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z\");\n    \t\t\tattr_dev(path, \"clip-rule\", \"evenodd\");\n    \t\t\tadd_location(path, file, 177, 20, 4696);\n    \t\t\tattr_dev(svg, \"id\", \"closed-lock\");\n    \t\t\tattr_dev(svg, \"xmlns\", \"http://www.w3.org/2000/svg\");\n    \t\t\tattr_dev(svg, \"class\", \"h-5 w-5 svelte-11rvpx5\");\n    \t\t\tattr_dev(svg, \"viewBox\", \"0 0 20 20\");\n    \t\t\tattr_dev(svg, \"fill\", \"currentColor\");\n    \t\t\tadd_location(svg, file, 176, 16, 4518);\n    \t\t},\n    \t\tm: function mount(target, anchor) {\n    \t\t\tinsert_hydration_dev(target, svg, anchor);\n    \t\t\tappend_hydration_dev(svg, path);\n\n    \t\t\tif (!mounted) {\n    \t\t\t\tdispose = listen_dev(svg, \"click\", /*click_handler_3*/ ctx[15], false, false, false);\n    \t\t\t\tmounted = true;\n    \t\t\t}\n    \t\t},\n    \t\tp: noop,\n    \t\td: function destroy(detaching) {\n    \t\t\tif (detaching) detach_dev(svg);\n    \t\t\tmounted = false;\n    \t\t\tdispose();\n    \t\t}\n    \t};\n\n    \tdispatch_dev(\"SvelteRegisterBlock\", {\n    \t\tblock,\n    \t\tid: create_else_block_3.name,\n    \t\ttype: \"else\",\n    \t\tsource: \"(176:12) {:else}\",\n    \t\tctx\n    \t});\n\n    \treturn block;\n    }\n\n    // (172:12) {#if !themeLock}\n    function create_if_block_3(ctx) {\n    \tlet svg;\n    \tlet path;\n    \tlet mounted;\n    \tlet dispose;\n\n    \tconst block = {\n    \t\tc: function create() {\n    \t\t\tsvg = svg_element(\"svg\");\n    \t\t\tpath = svg_element(\"path\");\n    \t\t\tthis.h();\n    \t\t},\n    \t\tl: function claim(nodes) {\n    \t\t\tsvg = claim_svg_element(nodes, \"svg\", {\n    \t\t\t\txmlns: true,\n    \t\t\t\tclass: true,\n    \t\t\t\tviewBox: true,\n    \t\t\t\tfill: true\n    \t\t\t});\n\n    \t\t\tvar svg_nodes = children(svg);\n    \t\t\tpath = claim_svg_element(svg_nodes, \"path\", { d: true });\n    \t\t\tchildren(path).forEach(detach_dev);\n    \t\t\tsvg_nodes.forEach(detach_dev);\n    \t\t\tthis.h();\n    \t\t},\n    \t\th: function hydrate() {\n    \t\t\tattr_dev(path, \"d\", \"M10 2a5 5 0 00-5 5v2a2 2 0 00-2 2v5a2 2 0 002 2h10a2 2 0 002-2v-5a2 2 0 00-2-2H7V7a3 3 0 015.905-.75 1 1 0 001.937-.5A5.002 5.002 0 0010 2z\");\n    \t\t\tadd_location(path, file, 173, 20, 4303);\n    \t\t\tattr_dev(svg, \"xmlns\", \"http://www.w3.org/2000/svg\");\n    \t\t\tattr_dev(svg, \"class\", \"h-5 w-5 svelte-11rvpx5\");\n    \t\t\tattr_dev(svg, \"viewBox\", \"0 0 20 20\");\n    \t\t\tattr_dev(svg, \"fill\", \"currentColor\");\n    \t\t\tadd_location(svg, file, 172, 16, 4142);\n    \t\t},\n    \t\tm: function mount(target, anchor) {\n    \t\t\tinsert_hydration_dev(target, svg, anchor);\n    \t\t\tappend_hydration_dev(svg, path);\n\n    \t\t\tif (!mounted) {\n    \t\t\t\tdispose = listen_dev(svg, \"click\", /*click_handler_2*/ ctx[14], false, false, false);\n    \t\t\t\tmounted = true;\n    \t\t\t}\n    \t\t},\n    \t\tp: noop,\n    \t\td: function destroy(detaching) {\n    \t\t\tif (detaching) detach_dev(svg);\n    \t\t\tmounted = false;\n    \t\t\tdispose();\n    \t\t}\n    \t};\n\n    \tdispatch_dev(\"SvelteRegisterBlock\", {\n    \t\tblock,\n    \t\tid: create_if_block_3.name,\n    \t\ttype: \"if\",\n    \t\tsource: \"(172:12) {#if !themeLock}\",\n    \t\tctx\n    \t});\n\n    \treturn block;\n    }\n\n    // (184:8) {:else}\n    function create_else_block_2(ctx) {\n    \tlet h4;\n    \tlet t;\n\n    \tconst block = {\n    \t\tc: function create() {\n    \t\t\th4 = element(\"h4\");\n    \t\t\tt = text(/*themeTempField*/ ctx[7]);\n    \t\t\tthis.h();\n    \t\t},\n    \t\tl: function claim(nodes) {\n    \t\t\th4 = claim_element(nodes, \"H4\", { class: true });\n    \t\t\tvar h4_nodes = children(h4);\n    \t\t\tt = claim_text(h4_nodes, /*themeTempField*/ ctx[7]);\n    \t\t\th4_nodes.forEach(detach_dev);\n    \t\t\tthis.h();\n    \t\t},\n    \t\th: function hydrate() {\n    \t\t\tattr_dev(h4, \"class\", \"svelte-11rvpx5\");\n    \t\t\tadd_location(h4, file, 184, 12, 4997);\n    \t\t},\n    \t\tm: function mount(target, anchor) {\n    \t\t\tinsert_hydration_dev(target, h4, anchor);\n    \t\t\tappend_hydration_dev(h4, t);\n    \t\t},\n    \t\tp: function update(ctx, dirty) {\n    \t\t\tif (dirty & /*themeTempField*/ 128) set_data_dev(t, /*themeTempField*/ ctx[7]);\n    \t\t},\n    \t\td: function destroy(detaching) {\n    \t\t\tif (detaching) detach_dev(h4);\n    \t\t}\n    \t};\n\n    \tdispatch_dev(\"SvelteRegisterBlock\", {\n    \t\tblock,\n    \t\tid: create_else_block_2.name,\n    \t\ttype: \"else\",\n    \t\tsource: \"(184:8) {:else}\",\n    \t\tctx\n    \t});\n\n    \treturn block;\n    }\n\n    // (182:8) {#if !themeLock}\n    function create_if_block_2(ctx) {\n    \tlet h4;\n    \tlet t;\n\n    \tconst block = {\n    \t\tc: function create() {\n    \t\t\th4 = element(\"h4\");\n    \t\t\tt = text(/*theme*/ ctx[1]);\n    \t\t\tthis.h();\n    \t\t},\n    \t\tl: function claim(nodes) {\n    \t\t\th4 = claim_element(nodes, \"H4\", { class: true });\n    \t\t\tvar h4_nodes = children(h4);\n    \t\t\tt = claim_text(h4_nodes, /*theme*/ ctx[1]);\n    \t\t\th4_nodes.forEach(detach_dev);\n    \t\t\tthis.h();\n    \t\t},\n    \t\th: function hydrate() {\n    \t\t\tattr_dev(h4, \"class\", \"svelte-11rvpx5\");\n    \t\t\tadd_location(h4, file, 182, 12, 4950);\n    \t\t},\n    \t\tm: function mount(target, anchor) {\n    \t\t\tinsert_hydration_dev(target, h4, anchor);\n    \t\t\tappend_hydration_dev(h4, t);\n    \t\t},\n    \t\tp: function update(ctx, dirty) {\n    \t\t\tif (dirty & /*theme*/ 2) set_data_dev(t, /*theme*/ ctx[1]);\n    \t\t},\n    \t\td: function destroy(detaching) {\n    \t\t\tif (detaching) detach_dev(h4);\n    \t\t}\n    \t};\n\n    \tdispatch_dev(\"SvelteRegisterBlock\", {\n    \t\tblock,\n    \t\tid: create_if_block_2.name,\n    \t\ttype: \"if\",\n    \t\tsource: \"(182:8) {#if !themeLock}\",\n    \t\tctx\n    \t});\n\n    \treturn block;\n    }\n\n    // (193:12) {:else}\n    function create_else_block_1(ctx) {\n    \tlet svg;\n    \tlet path;\n    \tlet mounted;\n    \tlet dispose;\n\n    \tconst block = {\n    \t\tc: function create() {\n    \t\t\tsvg = svg_element(\"svg\");\n    \t\t\tpath = svg_element(\"path\");\n    \t\t\tthis.h();\n    \t\t},\n    \t\tl: function claim(nodes) {\n    \t\t\tsvg = claim_svg_element(nodes, \"svg\", {\n    \t\t\t\tid: true,\n    \t\t\t\txmlns: true,\n    \t\t\t\tclass: true,\n    \t\t\t\tviewBox: true,\n    \t\t\t\tfill: true\n    \t\t\t});\n\n    \t\t\tvar svg_nodes = children(svg);\n\n    \t\t\tpath = claim_svg_element(svg_nodes, \"path\", {\n    \t\t\t\t\"fill-rule\": true,\n    \t\t\t\td: true,\n    \t\t\t\t\"clip-rule\": true\n    \t\t\t});\n\n    \t\t\tchildren(path).forEach(detach_dev);\n    \t\t\tsvg_nodes.forEach(detach_dev);\n    \t\t\tthis.h();\n    \t\t},\n    \t\th: function hydrate() {\n    \t\t\tattr_dev(path, \"fill-rule\", \"evenodd\");\n    \t\t\tattr_dev(path, \"d\", \"M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z\");\n    \t\t\tattr_dev(path, \"clip-rule\", \"evenodd\");\n    \t\t\tadd_location(path, file, 194, 20, 5704);\n    \t\t\tattr_dev(svg, \"id\", \"closed-lock\");\n    \t\t\tattr_dev(svg, \"xmlns\", \"http://www.w3.org/2000/svg\");\n    \t\t\tattr_dev(svg, \"class\", \"h-5 w-5 svelte-11rvpx5\");\n    \t\t\tattr_dev(svg, \"viewBox\", \"0 0 20 20\");\n    \t\t\tattr_dev(svg, \"fill\", \"currentColor\");\n    \t\t\tadd_location(svg, file, 193, 16, 5526);\n    \t\t},\n    \t\tm: function mount(target, anchor) {\n    \t\t\tinsert_hydration_dev(target, svg, anchor);\n    \t\t\tappend_hydration_dev(svg, path);\n\n    \t\t\tif (!mounted) {\n    \t\t\t\tdispose = listen_dev(svg, \"click\", /*click_handler_5*/ ctx[17], false, false, false);\n    \t\t\t\tmounted = true;\n    \t\t\t}\n    \t\t},\n    \t\tp: noop,\n    \t\td: function destroy(detaching) {\n    \t\t\tif (detaching) detach_dev(svg);\n    \t\t\tmounted = false;\n    \t\t\tdispose();\n    \t\t}\n    \t};\n\n    \tdispatch_dev(\"SvelteRegisterBlock\", {\n    \t\tblock,\n    \t\tid: create_else_block_1.name,\n    \t\ttype: \"else\",\n    \t\tsource: \"(193:12) {:else}\",\n    \t\tctx\n    \t});\n\n    \treturn block;\n    }\n\n    // (189:12) {#if !genreLock}\n    function create_if_block_1(ctx) {\n    \tlet svg;\n    \tlet path;\n    \tlet mounted;\n    \tlet dispose;\n\n    \tconst block = {\n    \t\tc: function create() {\n    \t\t\tsvg = svg_element(\"svg\");\n    \t\t\tpath = svg_element(\"path\");\n    \t\t\tthis.h();\n    \t\t},\n    \t\tl: function claim(nodes) {\n    \t\t\tsvg = claim_svg_element(nodes, \"svg\", {\n    \t\t\t\txmlns: true,\n    \t\t\t\tclass: true,\n    \t\t\t\tviewBox: true,\n    \t\t\t\tfill: true\n    \t\t\t});\n\n    \t\t\tvar svg_nodes = children(svg);\n    \t\t\tpath = claim_svg_element(svg_nodes, \"path\", { d: true });\n    \t\t\tchildren(path).forEach(detach_dev);\n    \t\t\tsvg_nodes.forEach(detach_dev);\n    \t\t\tthis.h();\n    \t\t},\n    \t\th: function hydrate() {\n    \t\t\tattr_dev(path, \"d\", \"M10 2a5 5 0 00-5 5v2a2 2 0 00-2 2v5a2 2 0 002 2h10a2 2 0 002-2v-5a2 2 0 00-2-2H7V7a3 3 0 015.905-.75 1 1 0 001.937-.5A5.002 5.002 0 0010 2z\");\n    \t\t\tadd_location(path, file, 190, 20, 5311);\n    \t\t\tattr_dev(svg, \"xmlns\", \"http://www.w3.org/2000/svg\");\n    \t\t\tattr_dev(svg, \"class\", \"h-5 w-5 svelte-11rvpx5\");\n    \t\t\tattr_dev(svg, \"viewBox\", \"0 0 20 20\");\n    \t\t\tattr_dev(svg, \"fill\", \"currentColor\");\n    \t\t\tadd_location(svg, file, 189, 16, 5150);\n    \t\t},\n    \t\tm: function mount(target, anchor) {\n    \t\t\tinsert_hydration_dev(target, svg, anchor);\n    \t\t\tappend_hydration_dev(svg, path);\n\n    \t\t\tif (!mounted) {\n    \t\t\t\tdispose = listen_dev(svg, \"click\", /*click_handler_4*/ ctx[16], false, false, false);\n    \t\t\t\tmounted = true;\n    \t\t\t}\n    \t\t},\n    \t\tp: noop,\n    \t\td: function destroy(detaching) {\n    \t\t\tif (detaching) detach_dev(svg);\n    \t\t\tmounted = false;\n    \t\t\tdispose();\n    \t\t}\n    \t};\n\n    \tdispatch_dev(\"SvelteRegisterBlock\", {\n    \t\tblock,\n    \t\tid: create_if_block_1.name,\n    \t\ttype: \"if\",\n    \t\tsource: \"(189:12) {#if !genreLock}\",\n    \t\tctx\n    \t});\n\n    \treturn block;\n    }\n\n    // (201:8) {:else}\n    function create_else_block(ctx) {\n    \tlet h4;\n    \tlet t;\n\n    \tconst block = {\n    \t\tc: function create() {\n    \t\t\th4 = element(\"h4\");\n    \t\t\tt = text(/*genreTempField*/ ctx[8]);\n    \t\t\tthis.h();\n    \t\t},\n    \t\tl: function claim(nodes) {\n    \t\t\th4 = claim_element(nodes, \"H4\", { class: true });\n    \t\t\tvar h4_nodes = children(h4);\n    \t\t\tt = claim_text(h4_nodes, /*genreTempField*/ ctx[8]);\n    \t\t\th4_nodes.forEach(detach_dev);\n    \t\t\tthis.h();\n    \t\t},\n    \t\th: function hydrate() {\n    \t\t\tattr_dev(h4, \"class\", \"svelte-11rvpx5\");\n    \t\t\tadd_location(h4, file, 201, 12, 6005);\n    \t\t},\n    \t\tm: function mount(target, anchor) {\n    \t\t\tinsert_hydration_dev(target, h4, anchor);\n    \t\t\tappend_hydration_dev(h4, t);\n    \t\t},\n    \t\tp: function update(ctx, dirty) {\n    \t\t\tif (dirty & /*genreTempField*/ 256) set_data_dev(t, /*genreTempField*/ ctx[8]);\n    \t\t},\n    \t\td: function destroy(detaching) {\n    \t\t\tif (detaching) detach_dev(h4);\n    \t\t}\n    \t};\n\n    \tdispatch_dev(\"SvelteRegisterBlock\", {\n    \t\tblock,\n    \t\tid: create_else_block.name,\n    \t\ttype: \"else\",\n    \t\tsource: \"(201:8) {:else}\",\n    \t\tctx\n    \t});\n\n    \treturn block;\n    }\n\n    // (199:8) {#if !genreLock}\n    function create_if_block(ctx) {\n    \tlet h4;\n    \tlet t;\n\n    \tconst block = {\n    \t\tc: function create() {\n    \t\t\th4 = element(\"h4\");\n    \t\t\tt = text(/*genre*/ ctx[2]);\n    \t\t\tthis.h();\n    \t\t},\n    \t\tl: function claim(nodes) {\n    \t\t\th4 = claim_element(nodes, \"H4\", { class: true });\n    \t\t\tvar h4_nodes = children(h4);\n    \t\t\tt = claim_text(h4_nodes, /*genre*/ ctx[2]);\n    \t\t\th4_nodes.forEach(detach_dev);\n    \t\t\tthis.h();\n    \t\t},\n    \t\th: function hydrate() {\n    \t\t\tattr_dev(h4, \"class\", \"svelte-11rvpx5\");\n    \t\t\tadd_location(h4, file, 199, 12, 5958);\n    \t\t},\n    \t\tm: function mount(target, anchor) {\n    \t\t\tinsert_hydration_dev(target, h4, anchor);\n    \t\t\tappend_hydration_dev(h4, t);\n    \t\t},\n    \t\tp: function update(ctx, dirty) {\n    \t\t\tif (dirty & /*genre*/ 4) set_data_dev(t, /*genre*/ ctx[2]);\n    \t\t},\n    \t\td: function destroy(detaching) {\n    \t\t\tif (detaching) detach_dev(h4);\n    \t\t}\n    \t};\n\n    \tdispatch_dev(\"SvelteRegisterBlock\", {\n    \t\tblock,\n    \t\tid: create_if_block.name,\n    \t\ttype: \"if\",\n    \t\tsource: \"(199:8) {#if !genreLock}\",\n    \t\tctx\n    \t});\n\n    \treturn block;\n    }\n\n    function create_fragment(ctx) {\n    \tlet main;\n    \tlet h1;\n    \tlet t0;\n    \tlet t1;\n    \tlet div3;\n    \tlet div0;\n    \tlet legend0;\n    \tlet t2;\n    \tlet t3;\n    \tlet t4;\n    \tlet t5;\n    \tlet div1;\n    \tlet legend1;\n    \tlet t6;\n    \tlet t7;\n    \tlet t8;\n    \tlet t9;\n    \tlet div2;\n    \tlet legend2;\n    \tlet t10;\n    \tlet t11;\n    \tlet t12;\n    \tlet t13;\n    \tlet button;\n    \tlet t14;\n    \tlet t15;\n    \tlet footer;\n    \tlet div4;\n    \tlet t16;\n    \tlet a;\n    \tlet t17;\n    \tlet mounted;\n    \tlet dispose;\n\n    \tfunction select_block_type(ctx, dirty) {\n    \t\tif (!/*styleLock*/ ctx[3]) return create_if_block_5;\n    \t\treturn create_else_block_5;\n    \t}\n\n    \tlet current_block_type = select_block_type(ctx);\n    \tlet if_block0 = current_block_type(ctx);\n\n    \tfunction select_block_type_1(ctx, dirty) {\n    \t\tif (!/*styleLock*/ ctx[3]) return create_if_block_4;\n    \t\treturn create_else_block_4;\n    \t}\n\n    \tlet current_block_type_1 = select_block_type_1(ctx);\n    \tlet if_block1 = current_block_type_1(ctx);\n\n    \tfunction select_block_type_2(ctx, dirty) {\n    \t\tif (!/*themeLock*/ ctx[4]) return create_if_block_3;\n    \t\treturn create_else_block_3;\n    \t}\n\n    \tlet current_block_type_2 = select_block_type_2(ctx);\n    \tlet if_block2 = current_block_type_2(ctx);\n\n    \tfunction select_block_type_3(ctx, dirty) {\n    \t\tif (!/*themeLock*/ ctx[4]) return create_if_block_2;\n    \t\treturn create_else_block_2;\n    \t}\n\n    \tlet current_block_type_3 = select_block_type_3(ctx);\n    \tlet if_block3 = current_block_type_3(ctx);\n\n    \tfunction select_block_type_4(ctx, dirty) {\n    \t\tif (!/*genreLock*/ ctx[5]) return create_if_block_1;\n    \t\treturn create_else_block_1;\n    \t}\n\n    \tlet current_block_type_4 = select_block_type_4(ctx);\n    \tlet if_block4 = current_block_type_4(ctx);\n\n    \tfunction select_block_type_5(ctx, dirty) {\n    \t\tif (!/*genreLock*/ ctx[5]) return create_if_block;\n    \t\treturn create_else_block;\n    \t}\n\n    \tlet current_block_type_5 = select_block_type_5(ctx);\n    \tlet if_block5 = current_block_type_5(ctx);\n\n    \tconst block = {\n    \t\tc: function create() {\n    \t\t\tmain = element(\"main\");\n    \t\t\th1 = element(\"h1\");\n    \t\t\tt0 = text(\"Game Idea Generator\");\n    \t\t\tt1 = space();\n    \t\t\tdiv3 = element(\"div\");\n    \t\t\tdiv0 = element(\"div\");\n    \t\t\tlegend0 = element(\"legend\");\n    \t\t\tt2 = text(\"STYLE\");\n    \t\t\tt3 = space();\n    \t\t\tif_block0.c();\n    \t\t\tt4 = space();\n    \t\t\tif_block1.c();\n    \t\t\tt5 = space();\n    \t\t\tdiv1 = element(\"div\");\n    \t\t\tlegend1 = element(\"legend\");\n    \t\t\tt6 = text(\"THEME\");\n    \t\t\tt7 = space();\n    \t\t\tif_block2.c();\n    \t\t\tt8 = space();\n    \t\t\tif_block3.c();\n    \t\t\tt9 = space();\n    \t\t\tdiv2 = element(\"div\");\n    \t\t\tlegend2 = element(\"legend\");\n    \t\t\tt10 = text(\"GENRE\");\n    \t\t\tt11 = space();\n    \t\t\tif_block4.c();\n    \t\t\tt12 = space();\n    \t\t\tif_block5.c();\n    \t\t\tt13 = space();\n    \t\t\tbutton = element(\"button\");\n    \t\t\tt14 = text(\"GENERATE\");\n    \t\t\tt15 = space();\n    \t\t\tfooter = element(\"footer\");\n    \t\t\tdiv4 = element(\"div\");\n    \t\t\tt16 = text(\"Copyright 2021 - \");\n    \t\t\ta = element(\"a\");\n    \t\t\tt17 = text(\"ignurof.xyz\");\n    \t\t\tthis.h();\n    \t\t},\n    \t\tl: function claim(nodes) {\n    \t\t\tmain = claim_element(nodes, \"MAIN\", { class: true });\n    \t\t\tvar main_nodes = children(main);\n    \t\t\th1 = claim_element(main_nodes, \"H1\", { class: true });\n    \t\t\tvar h1_nodes = children(h1);\n    \t\t\tt0 = claim_text(h1_nodes, \"Game Idea Generator\");\n    \t\t\th1_nodes.forEach(detach_dev);\n    \t\t\tt1 = claim_space(main_nodes);\n    \t\t\tdiv3 = claim_element(main_nodes, \"DIV\", { class: true });\n    \t\t\tvar div3_nodes = children(div3);\n    \t\t\tdiv0 = claim_element(div3_nodes, \"DIV\", { class: true });\n    \t\t\tvar div0_nodes = children(div0);\n    \t\t\tlegend0 = claim_element(div0_nodes, \"LEGEND\", { class: true });\n    \t\t\tvar legend0_nodes = children(legend0);\n    \t\t\tt2 = claim_text(legend0_nodes, \"STYLE\");\n    \t\t\tlegend0_nodes.forEach(detach_dev);\n    \t\t\tt3 = claim_space(div0_nodes);\n    \t\t\tif_block0.l(div0_nodes);\n    \t\t\tdiv0_nodes.forEach(detach_dev);\n    \t\t\tt4 = claim_space(div3_nodes);\n    \t\t\tif_block1.l(div3_nodes);\n    \t\t\tt5 = claim_space(div3_nodes);\n    \t\t\tdiv1 = claim_element(div3_nodes, \"DIV\", { class: true });\n    \t\t\tvar div1_nodes = children(div1);\n    \t\t\tlegend1 = claim_element(div1_nodes, \"LEGEND\", { class: true });\n    \t\t\tvar legend1_nodes = children(legend1);\n    \t\t\tt6 = claim_text(legend1_nodes, \"THEME\");\n    \t\t\tlegend1_nodes.forEach(detach_dev);\n    \t\t\tt7 = claim_space(div1_nodes);\n    \t\t\tif_block2.l(div1_nodes);\n    \t\t\tdiv1_nodes.forEach(detach_dev);\n    \t\t\tt8 = claim_space(div3_nodes);\n    \t\t\tif_block3.l(div3_nodes);\n    \t\t\tt9 = claim_space(div3_nodes);\n    \t\t\tdiv2 = claim_element(div3_nodes, \"DIV\", { class: true });\n    \t\t\tvar div2_nodes = children(div2);\n    \t\t\tlegend2 = claim_element(div2_nodes, \"LEGEND\", { class: true });\n    \t\t\tvar legend2_nodes = children(legend2);\n    \t\t\tt10 = claim_text(legend2_nodes, \"GENRE\");\n    \t\t\tlegend2_nodes.forEach(detach_dev);\n    \t\t\tt11 = claim_space(div2_nodes);\n    \t\t\tif_block4.l(div2_nodes);\n    \t\t\tdiv2_nodes.forEach(detach_dev);\n    \t\t\tt12 = claim_space(div3_nodes);\n    \t\t\tif_block5.l(div3_nodes);\n    \t\t\tdiv3_nodes.forEach(detach_dev);\n    \t\t\tt13 = claim_space(main_nodes);\n    \t\t\tbutton = claim_element(main_nodes, \"BUTTON\", { class: true });\n    \t\t\tvar button_nodes = children(button);\n    \t\t\tt14 = claim_text(button_nodes, \"GENERATE\");\n    \t\t\tbutton_nodes.forEach(detach_dev);\n    \t\t\tt15 = claim_space(main_nodes);\n    \t\t\tfooter = claim_element(main_nodes, \"FOOTER\", { class: true });\n    \t\t\tvar footer_nodes = children(footer);\n    \t\t\tdiv4 = claim_element(footer_nodes, \"DIV\", { class: true });\n    \t\t\tvar div4_nodes = children(div4);\n    \t\t\tt16 = claim_text(div4_nodes, \"Copyright 2021 - \");\n    \t\t\ta = claim_element(div4_nodes, \"A\", { href: true, target: true, class: true });\n    \t\t\tvar a_nodes = children(a);\n    \t\t\tt17 = claim_text(a_nodes, \"ignurof.xyz\");\n    \t\t\ta_nodes.forEach(detach_dev);\n    \t\t\tdiv4_nodes.forEach(detach_dev);\n    \t\t\tfooter_nodes.forEach(detach_dev);\n    \t\t\tmain_nodes.forEach(detach_dev);\n    \t\t\tthis.h();\n    \t\t},\n    \t\th: function hydrate() {\n    \t\t\tattr_dev(h1, \"class\", \"svelte-11rvpx5\");\n    \t\t\tadd_location(h1, file, 147, 4, 2963);\n    \t\t\tattr_dev(legend0, \"class\", \"svelte-11rvpx5\");\n    \t\t\tadd_location(legend0, file, 152, 12, 3062);\n    \t\t\tattr_dev(div0, \"class\", \"field svelte-11rvpx5\");\n    \t\t\tadd_location(div0, file, 151, 8, 3029);\n    \t\t\tattr_dev(legend1, \"class\", \"svelte-11rvpx5\");\n    \t\t\tadd_location(legend1, file, 170, 12, 4072);\n    \t\t\tattr_dev(div1, \"class\", \"field svelte-11rvpx5\");\n    \t\t\tadd_location(div1, file, 169, 8, 4039);\n    \t\t\tattr_dev(legend2, \"class\", \"svelte-11rvpx5\");\n    \t\t\tadd_location(legend2, file, 187, 12, 5080);\n    \t\t\tattr_dev(div2, \"class\", \"field svelte-11rvpx5\");\n    \t\t\tadd_location(div2, file, 186, 8, 5047);\n    \t\t\tattr_dev(div3, \"class\", \"card svelte-11rvpx5\");\n    \t\t\tadd_location(div3, file, 149, 4, 2999);\n    \t\t\tattr_dev(button, \"class\", \"svelte-11rvpx5\");\n    \t\t\tadd_location(button, file, 206, 4, 6079);\n    \t\t\tattr_dev(a, \"href\", \"ignurof.xyz\");\n    \t\t\tattr_dev(a, \"target\", \"_blank\");\n    \t\t\tattr_dev(a, \"class\", \"svelte-11rvpx5\");\n    \t\t\tadd_location(a, file, 210, 29, 6214);\n    \t\t\tattr_dev(div4, \"class\", \"credits svelte-11rvpx5\");\n    \t\t\tadd_location(div4, file, 209, 8, 6162);\n    \t\t\tattr_dev(footer, \"class\", \"svelte-11rvpx5\");\n    \t\t\tadd_location(footer, file, 208, 4, 6144);\n    \t\t\tattr_dev(main, \"class\", \"svelte-11rvpx5\");\n    \t\t\tadd_location(main, file, 146, 0, 2951);\n    \t\t},\n    \t\tm: function mount(target, anchor) {\n    \t\t\tinsert_hydration_dev(target, main, anchor);\n    \t\t\tappend_hydration_dev(main, h1);\n    \t\t\tappend_hydration_dev(h1, t0);\n    \t\t\tappend_hydration_dev(main, t1);\n    \t\t\tappend_hydration_dev(main, div3);\n    \t\t\tappend_hydration_dev(div3, div0);\n    \t\t\tappend_hydration_dev(div0, legend0);\n    \t\t\tappend_hydration_dev(legend0, t2);\n    \t\t\tappend_hydration_dev(div0, t3);\n    \t\t\tif_block0.m(div0, null);\n    \t\t\tappend_hydration_dev(div3, t4);\n    \t\t\tif_block1.m(div3, null);\n    \t\t\tappend_hydration_dev(div3, t5);\n    \t\t\tappend_hydration_dev(div3, div1);\n    \t\t\tappend_hydration_dev(div1, legend1);\n    \t\t\tappend_hydration_dev(legend1, t6);\n    \t\t\tappend_hydration_dev(div1, t7);\n    \t\t\tif_block2.m(div1, null);\n    \t\t\tappend_hydration_dev(div3, t8);\n    \t\t\tif_block3.m(div3, null);\n    \t\t\tappend_hydration_dev(div3, t9);\n    \t\t\tappend_hydration_dev(div3, div2);\n    \t\t\tappend_hydration_dev(div2, legend2);\n    \t\t\tappend_hydration_dev(legend2, t10);\n    \t\t\tappend_hydration_dev(div2, t11);\n    \t\t\tif_block4.m(div2, null);\n    \t\t\tappend_hydration_dev(div3, t12);\n    \t\t\tif_block5.m(div3, null);\n    \t\t\tappend_hydration_dev(main, t13);\n    \t\t\tappend_hydration_dev(main, button);\n    \t\t\tappend_hydration_dev(button, t14);\n    \t\t\tappend_hydration_dev(main, t15);\n    \t\t\tappend_hydration_dev(main, footer);\n    \t\t\tappend_hydration_dev(footer, div4);\n    \t\t\tappend_hydration_dev(div4, t16);\n    \t\t\tappend_hydration_dev(div4, a);\n    \t\t\tappend_hydration_dev(a, t17);\n\n    \t\t\tif (!mounted) {\n    \t\t\t\tdispose = listen_dev(button, \"click\", /*click_handler_6*/ ctx[18], false, false, false);\n    \t\t\t\tmounted = true;\n    \t\t\t}\n    \t\t},\n    \t\tp: function update(ctx, [dirty]) {\n    \t\t\tif (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {\n    \t\t\t\tif_block0.p(ctx, dirty);\n    \t\t\t} else {\n    \t\t\t\tif_block0.d(1);\n    \t\t\t\tif_block0 = current_block_type(ctx);\n\n    \t\t\t\tif (if_block0) {\n    \t\t\t\t\tif_block0.c();\n    \t\t\t\t\tif_block0.m(div0, null);\n    \t\t\t\t}\n    \t\t\t}\n\n    \t\t\tif (current_block_type_1 === (current_block_type_1 = select_block_type_1(ctx)) && if_block1) {\n    \t\t\t\tif_block1.p(ctx, dirty);\n    \t\t\t} else {\n    \t\t\t\tif_block1.d(1);\n    \t\t\t\tif_block1 = current_block_type_1(ctx);\n\n    \t\t\t\tif (if_block1) {\n    \t\t\t\t\tif_block1.c();\n    \t\t\t\t\tif_block1.m(div3, t5);\n    \t\t\t\t}\n    \t\t\t}\n\n    \t\t\tif (current_block_type_2 === (current_block_type_2 = select_block_type_2(ctx)) && if_block2) {\n    \t\t\t\tif_block2.p(ctx, dirty);\n    \t\t\t} else {\n    \t\t\t\tif_block2.d(1);\n    \t\t\t\tif_block2 = current_block_type_2(ctx);\n\n    \t\t\t\tif (if_block2) {\n    \t\t\t\t\tif_block2.c();\n    \t\t\t\t\tif_block2.m(div1, null);\n    \t\t\t\t}\n    \t\t\t}\n\n    \t\t\tif (current_block_type_3 === (current_block_type_3 = select_block_type_3(ctx)) && if_block3) {\n    \t\t\t\tif_block3.p(ctx, dirty);\n    \t\t\t} else {\n    \t\t\t\tif_block3.d(1);\n    \t\t\t\tif_block3 = current_block_type_3(ctx);\n\n    \t\t\t\tif (if_block3) {\n    \t\t\t\t\tif_block3.c();\n    \t\t\t\t\tif_block3.m(div3, t9);\n    \t\t\t\t}\n    \t\t\t}\n\n    \t\t\tif (current_block_type_4 === (current_block_type_4 = select_block_type_4(ctx)) && if_block4) {\n    \t\t\t\tif_block4.p(ctx, dirty);\n    \t\t\t} else {\n    \t\t\t\tif_block4.d(1);\n    \t\t\t\tif_block4 = current_block_type_4(ctx);\n\n    \t\t\t\tif (if_block4) {\n    \t\t\t\t\tif_block4.c();\n    \t\t\t\t\tif_block4.m(div2, null);\n    \t\t\t\t}\n    \t\t\t}\n\n    \t\t\tif (current_block_type_5 === (current_block_type_5 = select_block_type_5(ctx)) && if_block5) {\n    \t\t\t\tif_block5.p(ctx, dirty);\n    \t\t\t} else {\n    \t\t\t\tif_block5.d(1);\n    \t\t\t\tif_block5 = current_block_type_5(ctx);\n\n    \t\t\t\tif (if_block5) {\n    \t\t\t\t\tif_block5.c();\n    \t\t\t\t\tif_block5.m(div3, null);\n    \t\t\t\t}\n    \t\t\t}\n    \t\t},\n    \t\ti: noop,\n    \t\to: noop,\n    \t\td: function destroy(detaching) {\n    \t\t\tif (detaching) detach_dev(main);\n    \t\t\tif_block0.d();\n    \t\t\tif_block1.d();\n    \t\t\tif_block2.d();\n    \t\t\tif_block3.d();\n    \t\t\tif_block4.d();\n    \t\t\tif_block5.d();\n    \t\t\tmounted = false;\n    \t\t\tdispose();\n    \t\t}\n    \t};\n\n    \tdispatch_dev(\"SvelteRegisterBlock\", {\n    \t\tblock,\n    \t\tid: create_fragment.name,\n    \t\ttype: \"component\",\n    \t\tsource: \"\",\n    \t\tctx\n    \t});\n\n    \treturn block;\n    }\n\n    function instance($$self, $$props, $$invalidate) {\n    \tlet { $$slots: slots = {}, $$scope } = $$props;\n    \tvalidate_slots('Routes', slots, []);\n    \tlet { gameIdeaObj } = $$props;\n    \tlet style = gameIdeaObj.style;\n    \tlet theme = gameIdeaObj.theme;\n    \tlet genre = gameIdeaObj.genre;\n    \tlet styleLock = false;\n    \tlet themeLock = false;\n    \tlet genreLock = false;\n    \tlet styleTempField;\n    \tlet themeTempField;\n    \tlet genreTempField;\n\n    \t// Request idea object from backend\n    \tconst FetchNewIdea = async () => {\n    \t\tlet response = await fetch(\"/generate\");\n    \t\tif (!response.ok) return console.error(\"Something went wrong with generate request!\");\n    \t\tlet result = await response.json();\n    \t\t$$invalidate(0, style = result.style);\n    \t\t$$invalidate(1, theme = result.theme);\n    \t\t$$invalidate(2, genre = result.genre);\n    \t};\n\n    \t// Change lock and update fields accordingly\n    \tconst ChangeLockStatus = fieldType => {\n    \t\tif (fieldType === \"style\") {\n    \t\t\tif (!styleLock) {\n    \t\t\t\t$$invalidate(6, styleTempField = style);\n    \t\t\t} else $$invalidate(0, style = styleTempField);\n\n    \t\t\t$$invalidate(3, styleLock = !styleLock);\n    \t\t}\n\n    \t\tif (fieldType === \"theme\") {\n    \t\t\tif (!themeLock) {\n    \t\t\t\t$$invalidate(7, themeTempField = theme);\n    \t\t\t} else $$invalidate(1, theme = themeTempField);\n\n    \t\t\t$$invalidate(4, themeLock = !themeLock);\n    \t\t}\n\n    \t\tif (fieldType === \"genre\") {\n    \t\t\tif (!genreLock) {\n    \t\t\t\t$$invalidate(8, genreTempField = genre);\n    \t\t\t} else $$invalidate(2, genre = genreTempField);\n\n    \t\t\t$$invalidate(5, genreLock = !genreLock);\n    \t\t}\n    \t};\n\n    \tconst writable_props = ['gameIdeaObj'];\n\n    \tObject.keys($$props).forEach(key => {\n    \t\tif (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<Routes> was created with unknown prop '${key}'`);\n    \t});\n\n    \tconst click_handler = () => ChangeLockStatus(\"style\");\n    \tconst click_handler_1 = () => ChangeLockStatus(\"style\");\n    \tconst click_handler_2 = () => ChangeLockStatus(\"theme\");\n    \tconst click_handler_3 = () => ChangeLockStatus(\"theme\");\n    \tconst click_handler_4 = () => ChangeLockStatus(\"genre\");\n    \tconst click_handler_5 = () => ChangeLockStatus(\"genre\");\n    \tconst click_handler_6 = () => FetchNewIdea();\n\n    \t$$self.$$set = $$props => {\n    \t\tif ('gameIdeaObj' in $$props) $$invalidate(11, gameIdeaObj = $$props.gameIdeaObj);\n    \t};\n\n    \t$$self.$capture_state = () => ({\n    \t\tgameIdeaObj,\n    \t\tstyle,\n    \t\ttheme,\n    \t\tgenre,\n    \t\tstyleLock,\n    \t\tthemeLock,\n    \t\tgenreLock,\n    \t\tstyleTempField,\n    \t\tthemeTempField,\n    \t\tgenreTempField,\n    \t\tFetchNewIdea,\n    \t\tChangeLockStatus\n    \t});\n\n    \t$$self.$inject_state = $$props => {\n    \t\tif ('gameIdeaObj' in $$props) $$invalidate(11, gameIdeaObj = $$props.gameIdeaObj);\n    \t\tif ('style' in $$props) $$invalidate(0, style = $$props.style);\n    \t\tif ('theme' in $$props) $$invalidate(1, theme = $$props.theme);\n    \t\tif ('genre' in $$props) $$invalidate(2, genre = $$props.genre);\n    \t\tif ('styleLock' in $$props) $$invalidate(3, styleLock = $$props.styleLock);\n    \t\tif ('themeLock' in $$props) $$invalidate(4, themeLock = $$props.themeLock);\n    \t\tif ('genreLock' in $$props) $$invalidate(5, genreLock = $$props.genreLock);\n    \t\tif ('styleTempField' in $$props) $$invalidate(6, styleTempField = $$props.styleTempField);\n    \t\tif ('themeTempField' in $$props) $$invalidate(7, themeTempField = $$props.themeTempField);\n    \t\tif ('genreTempField' in $$props) $$invalidate(8, genreTempField = $$props.genreTempField);\n    \t};\n\n    \tif ($$props && \"$$inject\" in $$props) {\n    \t\t$$self.$inject_state($$props.$$inject);\n    \t}\n\n    \treturn [\n    \t\tstyle,\n    \t\ttheme,\n    \t\tgenre,\n    \t\tstyleLock,\n    \t\tthemeLock,\n    \t\tgenreLock,\n    \t\tstyleTempField,\n    \t\tthemeTempField,\n    \t\tgenreTempField,\n    \t\tFetchNewIdea,\n    \t\tChangeLockStatus,\n    \t\tgameIdeaObj,\n    \t\tclick_handler,\n    \t\tclick_handler_1,\n    \t\tclick_handler_2,\n    \t\tclick_handler_3,\n    \t\tclick_handler_4,\n    \t\tclick_handler_5,\n    \t\tclick_handler_6\n    \t];\n    }\n\n    class Routes extends SvelteComponentDev {\n    \tconstructor(options) {\n    \t\tsuper(options);\n    \t\tinit(this, options, instance, create_fragment, safe_not_equal, { gameIdeaObj: 11 });\n\n    \t\tdispatch_dev(\"SvelteRegisterComponent\", {\n    \t\t\tcomponent: this,\n    \t\t\ttagName: \"Routes\",\n    \t\t\toptions,\n    \t\t\tid: create_fragment.name\n    \t\t});\n\n    \t\tconst { ctx } = this.$$;\n    \t\tconst props = options.props || {};\n\n    \t\tif (/*gameIdeaObj*/ ctx[11] === undefined && !('gameIdeaObj' in props)) {\n    \t\t\tconsole_1.warn(\"<Routes> was created without expected prop 'gameIdeaObj'\");\n    \t\t}\n    \t}\n\n    \tget gameIdeaObj() {\n    \t\tthrow new Error(\"<Routes>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n    \t}\n\n    \tset gameIdeaObj(value) {\n    \t\tthrow new Error(\"<Routes>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n    \t}\n    }",
                    "originalLength": 7014,
                    "removedExports": [],
                    "renderedExports": [
                        "default"
                    ],
                    "renderedLength": 30982
                }
            },
            "name": "index",
            "type": "chunk",
            "code": "var Index = (function () {\n    'use strict';\n\n    function noop() { }\n    function add_location(element, file, line, column, char) {\n        element.__svelte_meta = {\n            loc: { file, line, column, char }\n        };\n    }\n    function run(fn) {\n        return fn();\n    }\n    function blank_object() {\n        return Object.create(null);\n    }\n    function run_all(fns) {\n        fns.forEach(run);\n    }\n    function is_function(thing) {\n        return typeof thing === 'function';\n    }\n    function safe_not_equal(a, b) {\n        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');\n    }\n    function is_empty(obj) {\n        return Object.keys(obj).length === 0;\n    }\n\n    // Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM\n    // at the end of hydration without touching the remaining nodes.\n    let is_hydrating = false;\n    function start_hydrating() {\n        is_hydrating = true;\n    }\n    function end_hydrating() {\n        is_hydrating = false;\n    }\n    function upper_bound(low, high, key, value) {\n        // Return first index of value larger than input value in the range [low, high)\n        while (low < high) {\n            const mid = low + ((high - low) >> 1);\n            if (key(mid) <= value) {\n                low = mid + 1;\n            }\n            else {\n                high = mid;\n            }\n        }\n        return low;\n    }\n    function init_hydrate(target) {\n        if (target.hydrate_init)\n            return;\n        target.hydrate_init = true;\n        // We know that all children have claim_order values since the unclaimed have been detached if target is not <head>\n        let children = target.childNodes;\n        // If target is <head>, there may be children without claim_order\n        if (target.nodeName === 'HEAD') {\n            const myChildren = [];\n            for (let i = 0; i < children.length; i++) {\n                const node = children[i];\n                if (node.claim_order !== undefined) {\n                    myChildren.push(node);\n                }\n            }\n            children = myChildren;\n        }\n        /*\n        * Reorder claimed children optimally.\n        * We can reorder claimed children optimally by finding the longest subsequence of\n        * nodes that are already claimed in order and only moving the rest. The longest\n        * subsequence subsequence of nodes that are claimed in order can be found by\n        * computing the longest increasing subsequence of .claim_order values.\n        *\n        * This algorithm is optimal in generating the least amount of reorder operations\n        * possible.\n        *\n        * Proof:\n        * We know that, given a set of reordering operations, the nodes that do not move\n        * always form an increasing subsequence, since they do not move among each other\n        * meaning that they must be already ordered among each other. Thus, the maximal\n        * set of nodes that do not move form a longest increasing subsequence.\n        */\n        // Compute longest increasing subsequence\n        // m: subsequence length j => index k of smallest value that ends an increasing subsequence of length j\n        const m = new Int32Array(children.length + 1);\n        // Predecessor indices + 1\n        const p = new Int32Array(children.length);\n        m[0] = -1;\n        let longest = 0;\n        for (let i = 0; i < children.length; i++) {\n            const current = children[i].claim_order;\n            // Find the largest subsequence length such that it ends in a value less than our current value\n            // upper_bound returns first greater value, so we subtract one\n            // with fast path for when we are on the current longest subsequence\n            const seqLen = ((longest > 0 && children[m[longest]].claim_order <= current) ? longest + 1 : upper_bound(1, longest, idx => children[m[idx]].claim_order, current)) - 1;\n            p[i] = m[seqLen] + 1;\n            const newLen = seqLen + 1;\n            // We can guarantee that current is the smallest value. Otherwise, we would have generated a longer sequence.\n            m[newLen] = i;\n            longest = Math.max(newLen, longest);\n        }\n        // The longest increasing subsequence of nodes (initially reversed)\n        const lis = [];\n        // The rest of the nodes, nodes that will be moved\n        const toMove = [];\n        let last = children.length - 1;\n        for (let cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {\n            lis.push(children[cur - 1]);\n            for (; last >= cur; last--) {\n                toMove.push(children[last]);\n            }\n            last--;\n        }\n        for (; last >= 0; last--) {\n            toMove.push(children[last]);\n        }\n        lis.reverse();\n        // We sort the nodes being moved to guarantee that their insertion order matches the claim order\n        toMove.sort((a, b) => a.claim_order - b.claim_order);\n        // Finally, we move the nodes\n        for (let i = 0, j = 0; i < toMove.length; i++) {\n            while (j < lis.length && toMove[i].claim_order >= lis[j].claim_order) {\n                j++;\n            }\n            const anchor = j < lis.length ? lis[j] : null;\n            target.insertBefore(toMove[i], anchor);\n        }\n    }\n    function append_hydration(target, node) {\n        if (is_hydrating) {\n            init_hydrate(target);\n            if ((target.actual_end_child === undefined) || ((target.actual_end_child !== null) && (target.actual_end_child.parentElement !== target))) {\n                target.actual_end_child = target.firstChild;\n            }\n            // Skip nodes of undefined ordering\n            while ((target.actual_end_child !== null) && (target.actual_end_child.claim_order === undefined)) {\n                target.actual_end_child = target.actual_end_child.nextSibling;\n            }\n            if (node !== target.actual_end_child) {\n                // We only insert if the ordering of this node should be modified or the parent node is not target\n                if (node.claim_order !== undefined || node.parentNode !== target) {\n                    target.insertBefore(node, target.actual_end_child);\n                }\n            }\n            else {\n                target.actual_end_child = node.nextSibling;\n            }\n        }\n        else if (node.parentNode !== target || node.nextSibling !== null) {\n            target.appendChild(node);\n        }\n    }\n    function insert_hydration(target, node, anchor) {\n        if (is_hydrating && !anchor) {\n            append_hydration(target, node);\n        }\n        else if (node.parentNode !== target || node.nextSibling != anchor) {\n            target.insertBefore(node, anchor || null);\n        }\n    }\n    function detach(node) {\n        node.parentNode.removeChild(node);\n    }\n    function element(name) {\n        return document.createElement(name);\n    }\n    function svg_element(name) {\n        return document.createElementNS('http://www.w3.org/2000/svg', name);\n    }\n    function text(data) {\n        return document.createTextNode(data);\n    }\n    function space() {\n        return text(' ');\n    }\n    function listen(node, event, handler, options) {\n        node.addEventListener(event, handler, options);\n        return () => node.removeEventListener(event, handler, options);\n    }\n    function attr(node, attribute, value) {\n        if (value == null)\n            node.removeAttribute(attribute);\n        else if (node.getAttribute(attribute) !== value)\n            node.setAttribute(attribute, value);\n    }\n    function children(element) {\n        return Array.from(element.childNodes);\n    }\n    function init_claim_info(nodes) {\n        if (nodes.claim_info === undefined) {\n            nodes.claim_info = { last_index: 0, total_claimed: 0 };\n        }\n    }\n    function claim_node(nodes, predicate, processNode, createNode, dontUpdateLastIndex = false) {\n        // Try to find nodes in an order such that we lengthen the longest increasing subsequence\n        init_claim_info(nodes);\n        const resultNode = (() => {\n            // We first try to find an element after the previous one\n            for (let i = nodes.claim_info.last_index; i < nodes.length; i++) {\n                const node = nodes[i];\n                if (predicate(node)) {\n                    const replacement = processNode(node);\n                    if (replacement === undefined) {\n                        nodes.splice(i, 1);\n                    }\n                    else {\n                        nodes[i] = replacement;\n                    }\n                    if (!dontUpdateLastIndex) {\n                        nodes.claim_info.last_index = i;\n                    }\n                    return node;\n                }\n            }\n            // Otherwise, we try to find one before\n            // We iterate in reverse so that we don't go too far back\n            for (let i = nodes.claim_info.last_index - 1; i >= 0; i--) {\n                const node = nodes[i];\n                if (predicate(node)) {\n                    const replacement = processNode(node);\n                    if (replacement === undefined) {\n                        nodes.splice(i, 1);\n                    }\n                    else {\n                        nodes[i] = replacement;\n                    }\n                    if (!dontUpdateLastIndex) {\n                        nodes.claim_info.last_index = i;\n                    }\n                    else if (replacement === undefined) {\n                        // Since we spliced before the last_index, we decrease it\n                        nodes.claim_info.last_index--;\n                    }\n                    return node;\n                }\n            }\n            // If we can't find any matching node, we create a new one\n            return createNode();\n        })();\n        resultNode.claim_order = nodes.claim_info.total_claimed;\n        nodes.claim_info.total_claimed += 1;\n        return resultNode;\n    }\n    function claim_element_base(nodes, name, attributes, create_element) {\n        return claim_node(nodes, (node) => node.nodeName === name, (node) => {\n            const remove = [];\n            for (let j = 0; j < node.attributes.length; j++) {\n                const attribute = node.attributes[j];\n                if (!attributes[attribute.name]) {\n                    remove.push(attribute.name);\n                }\n            }\n            remove.forEach(v => node.removeAttribute(v));\n            return undefined;\n        }, () => create_element(name));\n    }\n    function claim_element(nodes, name, attributes) {\n        return claim_element_base(nodes, name, attributes, element);\n    }\n    function claim_svg_element(nodes, name, attributes) {\n        return claim_element_base(nodes, name, attributes, svg_element);\n    }\n    function claim_text(nodes, data) {\n        return claim_node(nodes, (node) => node.nodeType === 3, (node) => {\n            const dataStr = '' + data;\n            if (node.data.startsWith(dataStr)) {\n                if (node.data.length !== dataStr.length) {\n                    return node.splitText(dataStr.length);\n                }\n            }\n            else {\n                node.data = dataStr;\n            }\n        }, () => text(data), true // Text nodes should not update last index since it is likely not worth it to eliminate an increasing subsequence of actual elements\n        );\n    }\n    function claim_space(nodes) {\n        return claim_text(nodes, ' ');\n    }\n    function custom_event(type, detail, bubbles = false) {\n        const e = document.createEvent('CustomEvent');\n        e.initCustomEvent(type, bubbles, false, detail);\n        return e;\n    }\n\n    let current_component;\n    function set_current_component(component) {\n        current_component = component;\n    }\n\n    const dirty_components = [];\n    const binding_callbacks = [];\n    const render_callbacks = [];\n    const flush_callbacks = [];\n    const resolved_promise = Promise.resolve();\n    let update_scheduled = false;\n    function schedule_update() {\n        if (!update_scheduled) {\n            update_scheduled = true;\n            resolved_promise.then(flush);\n        }\n    }\n    function add_render_callback(fn) {\n        render_callbacks.push(fn);\n    }\n    let flushing = false;\n    const seen_callbacks = new Set();\n    function flush() {\n        if (flushing)\n            return;\n        flushing = true;\n        do {\n            // first, call beforeUpdate functions\n            // and update components\n            for (let i = 0; i < dirty_components.length; i += 1) {\n                const component = dirty_components[i];\n                set_current_component(component);\n                update(component.$$);\n            }\n            set_current_component(null);\n            dirty_components.length = 0;\n            while (binding_callbacks.length)\n                binding_callbacks.pop()();\n            // then, once components are updated, call\n            // afterUpdate functions. This may cause\n            // subsequent updates...\n            for (let i = 0; i < render_callbacks.length; i += 1) {\n                const callback = render_callbacks[i];\n                if (!seen_callbacks.has(callback)) {\n                    // ...so guard against infinite loops\n                    seen_callbacks.add(callback);\n                    callback();\n                }\n            }\n            render_callbacks.length = 0;\n        } while (dirty_components.length);\n        while (flush_callbacks.length) {\n            flush_callbacks.pop()();\n        }\n        update_scheduled = false;\n        flushing = false;\n        seen_callbacks.clear();\n    }\n    function update($$) {\n        if ($$.fragment !== null) {\n            $$.update();\n            run_all($$.before_update);\n            const dirty = $$.dirty;\n            $$.dirty = [-1];\n            $$.fragment && $$.fragment.p($$.ctx, dirty);\n            $$.after_update.forEach(add_render_callback);\n        }\n    }\n    const outroing = new Set();\n    function transition_in(block, local) {\n        if (block && block.i) {\n            outroing.delete(block);\n            block.i(local);\n        }\n    }\n\n    const globals = (typeof window !== 'undefined'\n        ? window\n        : typeof globalThis !== 'undefined'\n            ? globalThis\n            : global);\n    function mount_component(component, target, anchor, customElement) {\n        const { fragment, on_mount, on_destroy, after_update } = component.$$;\n        fragment && fragment.m(target, anchor);\n        if (!customElement) {\n            // onMount happens before the initial afterUpdate\n            add_render_callback(() => {\n                const new_on_destroy = on_mount.map(run).filter(is_function);\n                if (on_destroy) {\n                    on_destroy.push(...new_on_destroy);\n                }\n                else {\n                    // Edge case - component was destroyed immediately,\n                    // most likely as a result of a binding initialising\n                    run_all(new_on_destroy);\n                }\n                component.$$.on_mount = [];\n            });\n        }\n        after_update.forEach(add_render_callback);\n    }\n    function destroy_component(component, detaching) {\n        const $$ = component.$$;\n        if ($$.fragment !== null) {\n            run_all($$.on_destroy);\n            $$.fragment && $$.fragment.d(detaching);\n            // TODO null out other refs, including component.$$ (but need to\n            // preserve final state?)\n            $$.on_destroy = $$.fragment = null;\n            $$.ctx = [];\n        }\n    }\n    function make_dirty(component, i) {\n        if (component.$$.dirty[0] === -1) {\n            dirty_components.push(component);\n            schedule_update();\n            component.$$.dirty.fill(0);\n        }\n        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));\n    }\n    function init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {\n        const parent_component = current_component;\n        set_current_component(component);\n        const $$ = component.$$ = {\n            fragment: null,\n            ctx: null,\n            // state\n            props,\n            update: noop,\n            not_equal,\n            bound: blank_object(),\n            // lifecycle\n            on_mount: [],\n            on_destroy: [],\n            on_disconnect: [],\n            before_update: [],\n            after_update: [],\n            context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n            // everything else\n            callbacks: blank_object(),\n            dirty,\n            skip_bound: false,\n            root: options.target || parent_component.$$.root\n        };\n        append_styles && append_styles($$.root);\n        let ready = false;\n        $$.ctx = instance\n            ? instance(component, options.props || {}, (i, ret, ...rest) => {\n                const value = rest.length ? rest[0] : ret;\n                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n                    if (!$$.skip_bound && $$.bound[i])\n                        $$.bound[i](value);\n                    if (ready)\n                        make_dirty(component, i);\n                }\n                return ret;\n            })\n            : [];\n        $$.update();\n        ready = true;\n        run_all($$.before_update);\n        // `false` as a special case of no DOM component\n        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n        if (options.target) {\n            if (options.hydrate) {\n                start_hydrating();\n                const nodes = children(options.target);\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                $$.fragment && $$.fragment.l(nodes);\n                nodes.forEach(detach);\n            }\n            else {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                $$.fragment && $$.fragment.c();\n            }\n            if (options.intro)\n                transition_in(component.$$.fragment);\n            mount_component(component, options.target, options.anchor, options.customElement);\n            end_hydrating();\n            flush();\n        }\n        set_current_component(parent_component);\n    }\n    /**\n     * Base class for Svelte components. Used when dev=false.\n     */\n    class SvelteComponent {\n        $destroy() {\n            destroy_component(this, 1);\n            this.$destroy = noop;\n        }\n        $on(type, callback) {\n            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n            callbacks.push(callback);\n            return () => {\n                const index = callbacks.indexOf(callback);\n                if (index !== -1)\n                    callbacks.splice(index, 1);\n            };\n        }\n        $set($$props) {\n            if (this.$$set && !is_empty($$props)) {\n                this.$$.skip_bound = true;\n                this.$$set($$props);\n                this.$$.skip_bound = false;\n            }\n        }\n    }\n\n    function dispatch_dev(type, detail) {\n        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.44.1' }, detail), true));\n    }\n    function append_hydration_dev(target, node) {\n        dispatch_dev('SvelteDOMInsert', { target, node });\n        append_hydration(target, node);\n    }\n    function insert_hydration_dev(target, node, anchor) {\n        dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n        insert_hydration(target, node, anchor);\n    }\n    function detach_dev(node) {\n        dispatch_dev('SvelteDOMRemove', { node });\n        detach(node);\n    }\n    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {\n        const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];\n        if (has_prevent_default)\n            modifiers.push('preventDefault');\n        if (has_stop_propagation)\n            modifiers.push('stopPropagation');\n        dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });\n        const dispose = listen(node, event, handler, options);\n        return () => {\n            dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });\n            dispose();\n        };\n    }\n    function attr_dev(node, attribute, value) {\n        attr(node, attribute, value);\n        if (value == null)\n            dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });\n        else\n            dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });\n    }\n    function set_data_dev(text, data) {\n        data = '' + data;\n        if (text.wholeText === data)\n            return;\n        dispatch_dev('SvelteDOMSetData', { node: text, data });\n        text.data = data;\n    }\n    function validate_slots(name, slot, keys) {\n        for (const slot_key of Object.keys(slot)) {\n            if (!~keys.indexOf(slot_key)) {\n                console.warn(`<${name}> received an unexpected slot \"${slot_key}\".`);\n            }\n        }\n    }\n    /**\n     * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.\n     */\n    class SvelteComponentDev extends SvelteComponent {\n        constructor(options) {\n            if (!options || (!options.target && !options.$$inline)) {\n                throw new Error(\"'target' is a required option\");\n            }\n            super();\n        }\n        $destroy() {\n            super.$destroy();\n            this.$destroy = () => {\n                console.warn('Component was already destroyed'); // eslint-disable-line no-console\n            };\n        }\n        $capture_state() { }\n        $inject_state() { }\n    }\n\n    /* src\\routes\\index.svelte generated by Svelte v3.44.1 */\n\n    const { console: console_1 } = globals;\n    const file = \"src\\\\routes\\\\index.svelte\";\n\n    // (158:12) {:else}\n    function create_else_block_5(ctx) {\n    \tlet svg;\n    \tlet path;\n    \tlet mounted;\n    \tlet dispose;\n\n    \tconst block = {\n    \t\tc: function create() {\n    \t\t\tsvg = svg_element(\"svg\");\n    \t\t\tpath = svg_element(\"path\");\n    \t\t\tthis.h();\n    \t\t},\n    \t\tl: function claim(nodes) {\n    \t\t\tsvg = claim_svg_element(nodes, \"svg\", {\n    \t\t\t\tid: true,\n    \t\t\t\txmlns: true,\n    \t\t\t\tclass: true,\n    \t\t\t\tviewBox: true,\n    \t\t\t\tfill: true\n    \t\t\t});\n\n    \t\t\tvar svg_nodes = children(svg);\n\n    \t\t\tpath = claim_svg_element(svg_nodes, \"path\", {\n    \t\t\t\t\"fill-rule\": true,\n    \t\t\t\td: true,\n    \t\t\t\t\"clip-rule\": true\n    \t\t\t});\n\n    \t\t\tchildren(path).forEach(detach_dev);\n    \t\t\tsvg_nodes.forEach(detach_dev);\n    \t\t\tthis.h();\n    \t\t},\n    \t\th: function hydrate() {\n    \t\t\tattr_dev(path, \"fill-rule\", \"evenodd\");\n    \t\t\tattr_dev(path, \"d\", \"M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z\");\n    \t\t\tattr_dev(path, \"clip-rule\", \"evenodd\");\n    \t\t\tadd_location(path, file, 159, 20, 3686);\n    \t\t\tattr_dev(svg, \"id\", \"closed-lock\");\n    \t\t\tattr_dev(svg, \"xmlns\", \"http://www.w3.org/2000/svg\");\n    \t\t\tattr_dev(svg, \"class\", \"h-5 w-5 svelte-11rvpx5\");\n    \t\t\tattr_dev(svg, \"viewBox\", \"0 0 20 20\");\n    \t\t\tattr_dev(svg, \"fill\", \"currentColor\");\n    \t\t\tadd_location(svg, file, 158, 16, 3508);\n    \t\t},\n    \t\tm: function mount(target, anchor) {\n    \t\t\tinsert_hydration_dev(target, svg, anchor);\n    \t\t\tappend_hydration_dev(svg, path);\n\n    \t\t\tif (!mounted) {\n    \t\t\t\tdispose = listen_dev(svg, \"click\", /*click_handler_1*/ ctx[13], false, false, false);\n    \t\t\t\tmounted = true;\n    \t\t\t}\n    \t\t},\n    \t\tp: noop,\n    \t\td: function destroy(detaching) {\n    \t\t\tif (detaching) detach_dev(svg);\n    \t\t\tmounted = false;\n    \t\t\tdispose();\n    \t\t}\n    \t};\n\n    \tdispatch_dev(\"SvelteRegisterBlock\", {\n    \t\tblock,\n    \t\tid: create_else_block_5.name,\n    \t\ttype: \"else\",\n    \t\tsource: \"(158:12) {:else}\",\n    \t\tctx\n    \t});\n\n    \treturn block;\n    }\n\n    // (154:12) {#if !styleLock}\n    function create_if_block_5(ctx) {\n    \tlet svg;\n    \tlet path;\n    \tlet mounted;\n    \tlet dispose;\n\n    \tconst block = {\n    \t\tc: function create() {\n    \t\t\tsvg = svg_element(\"svg\");\n    \t\t\tpath = svg_element(\"path\");\n    \t\t\tthis.h();\n    \t\t},\n    \t\tl: function claim(nodes) {\n    \t\t\tsvg = claim_svg_element(nodes, \"svg\", {\n    \t\t\t\txmlns: true,\n    \t\t\t\tclass: true,\n    \t\t\t\tviewBox: true,\n    \t\t\t\tfill: true\n    \t\t\t});\n\n    \t\t\tvar svg_nodes = children(svg);\n    \t\t\tpath = claim_svg_element(svg_nodes, \"path\", { d: true });\n    \t\t\tchildren(path).forEach(detach_dev);\n    \t\t\tsvg_nodes.forEach(detach_dev);\n    \t\t\tthis.h();\n    \t\t},\n    \t\th: function hydrate() {\n    \t\t\tattr_dev(path, \"d\", \"M10 2a5 5 0 00-5 5v2a2 2 0 00-2 2v5a2 2 0 002 2h10a2 2 0 002-2v-5a2 2 0 00-2-2H7V7a3 3 0 015.905-.75 1 1 0 001.937-.5A5.002 5.002 0 0010 2z\");\n    \t\t\tadd_location(path, file, 155, 20, 3293);\n    \t\t\tattr_dev(svg, \"xmlns\", \"http://www.w3.org/2000/svg\");\n    \t\t\tattr_dev(svg, \"class\", \"h-5 w-5 svelte-11rvpx5\");\n    \t\t\tattr_dev(svg, \"viewBox\", \"0 0 20 20\");\n    \t\t\tattr_dev(svg, \"fill\", \"currentColor\");\n    \t\t\tadd_location(svg, file, 154, 16, 3132);\n    \t\t},\n    \t\tm: function mount(target, anchor) {\n    \t\t\tinsert_hydration_dev(target, svg, anchor);\n    \t\t\tappend_hydration_dev(svg, path);\n\n    \t\t\tif (!mounted) {\n    \t\t\t\tdispose = listen_dev(svg, \"click\", /*click_handler*/ ctx[12], false, false, false);\n    \t\t\t\tmounted = true;\n    \t\t\t}\n    \t\t},\n    \t\tp: noop,\n    \t\td: function destroy(detaching) {\n    \t\t\tif (detaching) detach_dev(svg);\n    \t\t\tmounted = false;\n    \t\t\tdispose();\n    \t\t}\n    \t};\n\n    \tdispatch_dev(\"SvelteRegisterBlock\", {\n    \t\tblock,\n    \t\tid: create_if_block_5.name,\n    \t\ttype: \"if\",\n    \t\tsource: \"(154:12) {#if !styleLock}\",\n    \t\tctx\n    \t});\n\n    \treturn block;\n    }\n\n    // (166:8) {:else}\n    function create_else_block_4(ctx) {\n    \tlet h4;\n    \tlet t;\n\n    \tconst block = {\n    \t\tc: function create() {\n    \t\t\th4 = element(\"h4\");\n    \t\t\tt = text(/*styleTempField*/ ctx[6]);\n    \t\t\tthis.h();\n    \t\t},\n    \t\tl: function claim(nodes) {\n    \t\t\th4 = claim_element(nodes, \"H4\", { class: true });\n    \t\t\tvar h4_nodes = children(h4);\n    \t\t\tt = claim_text(h4_nodes, /*styleTempField*/ ctx[6]);\n    \t\t\th4_nodes.forEach(detach_dev);\n    \t\t\tthis.h();\n    \t\t},\n    \t\th: function hydrate() {\n    \t\t\tattr_dev(h4, \"class\", \"svelte-11rvpx5\");\n    \t\t\tadd_location(h4, file, 166, 12, 3987);\n    \t\t},\n    \t\tm: function mount(target, anchor) {\n    \t\t\tinsert_hydration_dev(target, h4, anchor);\n    \t\t\tappend_hydration_dev(h4, t);\n    \t\t},\n    \t\tp: function update(ctx, dirty) {\n    \t\t\tif (dirty & /*styleTempField*/ 64) set_data_dev(t, /*styleTempField*/ ctx[6]);\n    \t\t},\n    \t\td: function destroy(detaching) {\n    \t\t\tif (detaching) detach_dev(h4);\n    \t\t}\n    \t};\n\n    \tdispatch_dev(\"SvelteRegisterBlock\", {\n    \t\tblock,\n    \t\tid: create_else_block_4.name,\n    \t\ttype: \"else\",\n    \t\tsource: \"(166:8) {:else}\",\n    \t\tctx\n    \t});\n\n    \treturn block;\n    }\n\n    // (164:8) {#if !styleLock}\n    function create_if_block_4(ctx) {\n    \tlet h4;\n    \tlet t;\n\n    \tconst block = {\n    \t\tc: function create() {\n    \t\t\th4 = element(\"h4\");\n    \t\t\tt = text(/*style*/ ctx[0]);\n    \t\t\tthis.h();\n    \t\t},\n    \t\tl: function claim(nodes) {\n    \t\t\th4 = claim_element(nodes, \"H4\", { class: true });\n    \t\t\tvar h4_nodes = children(h4);\n    \t\t\tt = claim_text(h4_nodes, /*style*/ ctx[0]);\n    \t\t\th4_nodes.forEach(detach_dev);\n    \t\t\tthis.h();\n    \t\t},\n    \t\th: function hydrate() {\n    \t\t\tattr_dev(h4, \"class\", \"svelte-11rvpx5\");\n    \t\t\tadd_location(h4, file, 164, 12, 3940);\n    \t\t},\n    \t\tm: function mount(target, anchor) {\n    \t\t\tinsert_hydration_dev(target, h4, anchor);\n    \t\t\tappend_hydration_dev(h4, t);\n    \t\t},\n    \t\tp: function update(ctx, dirty) {\n    \t\t\tif (dirty & /*style*/ 1) set_data_dev(t, /*style*/ ctx[0]);\n    \t\t},\n    \t\td: function destroy(detaching) {\n    \t\t\tif (detaching) detach_dev(h4);\n    \t\t}\n    \t};\n\n    \tdispatch_dev(\"SvelteRegisterBlock\", {\n    \t\tblock,\n    \t\tid: create_if_block_4.name,\n    \t\ttype: \"if\",\n    \t\tsource: \"(164:8) {#if !styleLock}\",\n    \t\tctx\n    \t});\n\n    \treturn block;\n    }\n\n    // (176:12) {:else}\n    function create_else_block_3(ctx) {\n    \tlet svg;\n    \tlet path;\n    \tlet mounted;\n    \tlet dispose;\n\n    \tconst block = {\n    \t\tc: function create() {\n    \t\t\tsvg = svg_element(\"svg\");\n    \t\t\tpath = svg_element(\"path\");\n    \t\t\tthis.h();\n    \t\t},\n    \t\tl: function claim(nodes) {\n    \t\t\tsvg = claim_svg_element(nodes, \"svg\", {\n    \t\t\t\tid: true,\n    \t\t\t\txmlns: true,\n    \t\t\t\tclass: true,\n    \t\t\t\tviewBox: true,\n    \t\t\t\tfill: true\n    \t\t\t});\n\n    \t\t\tvar svg_nodes = children(svg);\n\n    \t\t\tpath = claim_svg_element(svg_nodes, \"path\", {\n    \t\t\t\t\"fill-rule\": true,\n    \t\t\t\td: true,\n    \t\t\t\t\"clip-rule\": true\n    \t\t\t});\n\n    \t\t\tchildren(path).forEach(detach_dev);\n    \t\t\tsvg_nodes.forEach(detach_dev);\n    \t\t\tthis.h();\n    \t\t},\n    \t\th: function hydrate() {\n    \t\t\tattr_dev(path, \"fill-rule\", \"evenodd\");\n    \t\t\tattr_dev(path, \"d\", \"M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z\");\n    \t\t\tattr_dev(path, \"clip-rule\", \"evenodd\");\n    \t\t\tadd_location(path, file, 177, 20, 4696);\n    \t\t\tattr_dev(svg, \"id\", \"closed-lock\");\n    \t\t\tattr_dev(svg, \"xmlns\", \"http://www.w3.org/2000/svg\");\n    \t\t\tattr_dev(svg, \"class\", \"h-5 w-5 svelte-11rvpx5\");\n    \t\t\tattr_dev(svg, \"viewBox\", \"0 0 20 20\");\n    \t\t\tattr_dev(svg, \"fill\", \"currentColor\");\n    \t\t\tadd_location(svg, file, 176, 16, 4518);\n    \t\t},\n    \t\tm: function mount(target, anchor) {\n    \t\t\tinsert_hydration_dev(target, svg, anchor);\n    \t\t\tappend_hydration_dev(svg, path);\n\n    \t\t\tif (!mounted) {\n    \t\t\t\tdispose = listen_dev(svg, \"click\", /*click_handler_3*/ ctx[15], false, false, false);\n    \t\t\t\tmounted = true;\n    \t\t\t}\n    \t\t},\n    \t\tp: noop,\n    \t\td: function destroy(detaching) {\n    \t\t\tif (detaching) detach_dev(svg);\n    \t\t\tmounted = false;\n    \t\t\tdispose();\n    \t\t}\n    \t};\n\n    \tdispatch_dev(\"SvelteRegisterBlock\", {\n    \t\tblock,\n    \t\tid: create_else_block_3.name,\n    \t\ttype: \"else\",\n    \t\tsource: \"(176:12) {:else}\",\n    \t\tctx\n    \t});\n\n    \treturn block;\n    }\n\n    // (172:12) {#if !themeLock}\n    function create_if_block_3(ctx) {\n    \tlet svg;\n    \tlet path;\n    \tlet mounted;\n    \tlet dispose;\n\n    \tconst block = {\n    \t\tc: function create() {\n    \t\t\tsvg = svg_element(\"svg\");\n    \t\t\tpath = svg_element(\"path\");\n    \t\t\tthis.h();\n    \t\t},\n    \t\tl: function claim(nodes) {\n    \t\t\tsvg = claim_svg_element(nodes, \"svg\", {\n    \t\t\t\txmlns: true,\n    \t\t\t\tclass: true,\n    \t\t\t\tviewBox: true,\n    \t\t\t\tfill: true\n    \t\t\t});\n\n    \t\t\tvar svg_nodes = children(svg);\n    \t\t\tpath = claim_svg_element(svg_nodes, \"path\", { d: true });\n    \t\t\tchildren(path).forEach(detach_dev);\n    \t\t\tsvg_nodes.forEach(detach_dev);\n    \t\t\tthis.h();\n    \t\t},\n    \t\th: function hydrate() {\n    \t\t\tattr_dev(path, \"d\", \"M10 2a5 5 0 00-5 5v2a2 2 0 00-2 2v5a2 2 0 002 2h10a2 2 0 002-2v-5a2 2 0 00-2-2H7V7a3 3 0 015.905-.75 1 1 0 001.937-.5A5.002 5.002 0 0010 2z\");\n    \t\t\tadd_location(path, file, 173, 20, 4303);\n    \t\t\tattr_dev(svg, \"xmlns\", \"http://www.w3.org/2000/svg\");\n    \t\t\tattr_dev(svg, \"class\", \"h-5 w-5 svelte-11rvpx5\");\n    \t\t\tattr_dev(svg, \"viewBox\", \"0 0 20 20\");\n    \t\t\tattr_dev(svg, \"fill\", \"currentColor\");\n    \t\t\tadd_location(svg, file, 172, 16, 4142);\n    \t\t},\n    \t\tm: function mount(target, anchor) {\n    \t\t\tinsert_hydration_dev(target, svg, anchor);\n    \t\t\tappend_hydration_dev(svg, path);\n\n    \t\t\tif (!mounted) {\n    \t\t\t\tdispose = listen_dev(svg, \"click\", /*click_handler_2*/ ctx[14], false, false, false);\n    \t\t\t\tmounted = true;\n    \t\t\t}\n    \t\t},\n    \t\tp: noop,\n    \t\td: function destroy(detaching) {\n    \t\t\tif (detaching) detach_dev(svg);\n    \t\t\tmounted = false;\n    \t\t\tdispose();\n    \t\t}\n    \t};\n\n    \tdispatch_dev(\"SvelteRegisterBlock\", {\n    \t\tblock,\n    \t\tid: create_if_block_3.name,\n    \t\ttype: \"if\",\n    \t\tsource: \"(172:12) {#if !themeLock}\",\n    \t\tctx\n    \t});\n\n    \treturn block;\n    }\n\n    // (184:8) {:else}\n    function create_else_block_2(ctx) {\n    \tlet h4;\n    \tlet t;\n\n    \tconst block = {\n    \t\tc: function create() {\n    \t\t\th4 = element(\"h4\");\n    \t\t\tt = text(/*themeTempField*/ ctx[7]);\n    \t\t\tthis.h();\n    \t\t},\n    \t\tl: function claim(nodes) {\n    \t\t\th4 = claim_element(nodes, \"H4\", { class: true });\n    \t\t\tvar h4_nodes = children(h4);\n    \t\t\tt = claim_text(h4_nodes, /*themeTempField*/ ctx[7]);\n    \t\t\th4_nodes.forEach(detach_dev);\n    \t\t\tthis.h();\n    \t\t},\n    \t\th: function hydrate() {\n    \t\t\tattr_dev(h4, \"class\", \"svelte-11rvpx5\");\n    \t\t\tadd_location(h4, file, 184, 12, 4997);\n    \t\t},\n    \t\tm: function mount(target, anchor) {\n    \t\t\tinsert_hydration_dev(target, h4, anchor);\n    \t\t\tappend_hydration_dev(h4, t);\n    \t\t},\n    \t\tp: function update(ctx, dirty) {\n    \t\t\tif (dirty & /*themeTempField*/ 128) set_data_dev(t, /*themeTempField*/ ctx[7]);\n    \t\t},\n    \t\td: function destroy(detaching) {\n    \t\t\tif (detaching) detach_dev(h4);\n    \t\t}\n    \t};\n\n    \tdispatch_dev(\"SvelteRegisterBlock\", {\n    \t\tblock,\n    \t\tid: create_else_block_2.name,\n    \t\ttype: \"else\",\n    \t\tsource: \"(184:8) {:else}\",\n    \t\tctx\n    \t});\n\n    \treturn block;\n    }\n\n    // (182:8) {#if !themeLock}\n    function create_if_block_2(ctx) {\n    \tlet h4;\n    \tlet t;\n\n    \tconst block = {\n    \t\tc: function create() {\n    \t\t\th4 = element(\"h4\");\n    \t\t\tt = text(/*theme*/ ctx[1]);\n    \t\t\tthis.h();\n    \t\t},\n    \t\tl: function claim(nodes) {\n    \t\t\th4 = claim_element(nodes, \"H4\", { class: true });\n    \t\t\tvar h4_nodes = children(h4);\n    \t\t\tt = claim_text(h4_nodes, /*theme*/ ctx[1]);\n    \t\t\th4_nodes.forEach(detach_dev);\n    \t\t\tthis.h();\n    \t\t},\n    \t\th: function hydrate() {\n    \t\t\tattr_dev(h4, \"class\", \"svelte-11rvpx5\");\n    \t\t\tadd_location(h4, file, 182, 12, 4950);\n    \t\t},\n    \t\tm: function mount(target, anchor) {\n    \t\t\tinsert_hydration_dev(target, h4, anchor);\n    \t\t\tappend_hydration_dev(h4, t);\n    \t\t},\n    \t\tp: function update(ctx, dirty) {\n    \t\t\tif (dirty & /*theme*/ 2) set_data_dev(t, /*theme*/ ctx[1]);\n    \t\t},\n    \t\td: function destroy(detaching) {\n    \t\t\tif (detaching) detach_dev(h4);\n    \t\t}\n    \t};\n\n    \tdispatch_dev(\"SvelteRegisterBlock\", {\n    \t\tblock,\n    \t\tid: create_if_block_2.name,\n    \t\ttype: \"if\",\n    \t\tsource: \"(182:8) {#if !themeLock}\",\n    \t\tctx\n    \t});\n\n    \treturn block;\n    }\n\n    // (193:12) {:else}\n    function create_else_block_1(ctx) {\n    \tlet svg;\n    \tlet path;\n    \tlet mounted;\n    \tlet dispose;\n\n    \tconst block = {\n    \t\tc: function create() {\n    \t\t\tsvg = svg_element(\"svg\");\n    \t\t\tpath = svg_element(\"path\");\n    \t\t\tthis.h();\n    \t\t},\n    \t\tl: function claim(nodes) {\n    \t\t\tsvg = claim_svg_element(nodes, \"svg\", {\n    \t\t\t\tid: true,\n    \t\t\t\txmlns: true,\n    \t\t\t\tclass: true,\n    \t\t\t\tviewBox: true,\n    \t\t\t\tfill: true\n    \t\t\t});\n\n    \t\t\tvar svg_nodes = children(svg);\n\n    \t\t\tpath = claim_svg_element(svg_nodes, \"path\", {\n    \t\t\t\t\"fill-rule\": true,\n    \t\t\t\td: true,\n    \t\t\t\t\"clip-rule\": true\n    \t\t\t});\n\n    \t\t\tchildren(path).forEach(detach_dev);\n    \t\t\tsvg_nodes.forEach(detach_dev);\n    \t\t\tthis.h();\n    \t\t},\n    \t\th: function hydrate() {\n    \t\t\tattr_dev(path, \"fill-rule\", \"evenodd\");\n    \t\t\tattr_dev(path, \"d\", \"M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z\");\n    \t\t\tattr_dev(path, \"clip-rule\", \"evenodd\");\n    \t\t\tadd_location(path, file, 194, 20, 5704);\n    \t\t\tattr_dev(svg, \"id\", \"closed-lock\");\n    \t\t\tattr_dev(svg, \"xmlns\", \"http://www.w3.org/2000/svg\");\n    \t\t\tattr_dev(svg, \"class\", \"h-5 w-5 svelte-11rvpx5\");\n    \t\t\tattr_dev(svg, \"viewBox\", \"0 0 20 20\");\n    \t\t\tattr_dev(svg, \"fill\", \"currentColor\");\n    \t\t\tadd_location(svg, file, 193, 16, 5526);\n    \t\t},\n    \t\tm: function mount(target, anchor) {\n    \t\t\tinsert_hydration_dev(target, svg, anchor);\n    \t\t\tappend_hydration_dev(svg, path);\n\n    \t\t\tif (!mounted) {\n    \t\t\t\tdispose = listen_dev(svg, \"click\", /*click_handler_5*/ ctx[17], false, false, false);\n    \t\t\t\tmounted = true;\n    \t\t\t}\n    \t\t},\n    \t\tp: noop,\n    \t\td: function destroy(detaching) {\n    \t\t\tif (detaching) detach_dev(svg);\n    \t\t\tmounted = false;\n    \t\t\tdispose();\n    \t\t}\n    \t};\n\n    \tdispatch_dev(\"SvelteRegisterBlock\", {\n    \t\tblock,\n    \t\tid: create_else_block_1.name,\n    \t\ttype: \"else\",\n    \t\tsource: \"(193:12) {:else}\",\n    \t\tctx\n    \t});\n\n    \treturn block;\n    }\n\n    // (189:12) {#if !genreLock}\n    function create_if_block_1(ctx) {\n    \tlet svg;\n    \tlet path;\n    \tlet mounted;\n    \tlet dispose;\n\n    \tconst block = {\n    \t\tc: function create() {\n    \t\t\tsvg = svg_element(\"svg\");\n    \t\t\tpath = svg_element(\"path\");\n    \t\t\tthis.h();\n    \t\t},\n    \t\tl: function claim(nodes) {\n    \t\t\tsvg = claim_svg_element(nodes, \"svg\", {\n    \t\t\t\txmlns: true,\n    \t\t\t\tclass: true,\n    \t\t\t\tviewBox: true,\n    \t\t\t\tfill: true\n    \t\t\t});\n\n    \t\t\tvar svg_nodes = children(svg);\n    \t\t\tpath = claim_svg_element(svg_nodes, \"path\", { d: true });\n    \t\t\tchildren(path).forEach(detach_dev);\n    \t\t\tsvg_nodes.forEach(detach_dev);\n    \t\t\tthis.h();\n    \t\t},\n    \t\th: function hydrate() {\n    \t\t\tattr_dev(path, \"d\", \"M10 2a5 5 0 00-5 5v2a2 2 0 00-2 2v5a2 2 0 002 2h10a2 2 0 002-2v-5a2 2 0 00-2-2H7V7a3 3 0 015.905-.75 1 1 0 001.937-.5A5.002 5.002 0 0010 2z\");\n    \t\t\tadd_location(path, file, 190, 20, 5311);\n    \t\t\tattr_dev(svg, \"xmlns\", \"http://www.w3.org/2000/svg\");\n    \t\t\tattr_dev(svg, \"class\", \"h-5 w-5 svelte-11rvpx5\");\n    \t\t\tattr_dev(svg, \"viewBox\", \"0 0 20 20\");\n    \t\t\tattr_dev(svg, \"fill\", \"currentColor\");\n    \t\t\tadd_location(svg, file, 189, 16, 5150);\n    \t\t},\n    \t\tm: function mount(target, anchor) {\n    \t\t\tinsert_hydration_dev(target, svg, anchor);\n    \t\t\tappend_hydration_dev(svg, path);\n\n    \t\t\tif (!mounted) {\n    \t\t\t\tdispose = listen_dev(svg, \"click\", /*click_handler_4*/ ctx[16], false, false, false);\n    \t\t\t\tmounted = true;\n    \t\t\t}\n    \t\t},\n    \t\tp: noop,\n    \t\td: function destroy(detaching) {\n    \t\t\tif (detaching) detach_dev(svg);\n    \t\t\tmounted = false;\n    \t\t\tdispose();\n    \t\t}\n    \t};\n\n    \tdispatch_dev(\"SvelteRegisterBlock\", {\n    \t\tblock,\n    \t\tid: create_if_block_1.name,\n    \t\ttype: \"if\",\n    \t\tsource: \"(189:12) {#if !genreLock}\",\n    \t\tctx\n    \t});\n\n    \treturn block;\n    }\n\n    // (201:8) {:else}\n    function create_else_block(ctx) {\n    \tlet h4;\n    \tlet t;\n\n    \tconst block = {\n    \t\tc: function create() {\n    \t\t\th4 = element(\"h4\");\n    \t\t\tt = text(/*genreTempField*/ ctx[8]);\n    \t\t\tthis.h();\n    \t\t},\n    \t\tl: function claim(nodes) {\n    \t\t\th4 = claim_element(nodes, \"H4\", { class: true });\n    \t\t\tvar h4_nodes = children(h4);\n    \t\t\tt = claim_text(h4_nodes, /*genreTempField*/ ctx[8]);\n    \t\t\th4_nodes.forEach(detach_dev);\n    \t\t\tthis.h();\n    \t\t},\n    \t\th: function hydrate() {\n    \t\t\tattr_dev(h4, \"class\", \"svelte-11rvpx5\");\n    \t\t\tadd_location(h4, file, 201, 12, 6005);\n    \t\t},\n    \t\tm: function mount(target, anchor) {\n    \t\t\tinsert_hydration_dev(target, h4, anchor);\n    \t\t\tappend_hydration_dev(h4, t);\n    \t\t},\n    \t\tp: function update(ctx, dirty) {\n    \t\t\tif (dirty & /*genreTempField*/ 256) set_data_dev(t, /*genreTempField*/ ctx[8]);\n    \t\t},\n    \t\td: function destroy(detaching) {\n    \t\t\tif (detaching) detach_dev(h4);\n    \t\t}\n    \t};\n\n    \tdispatch_dev(\"SvelteRegisterBlock\", {\n    \t\tblock,\n    \t\tid: create_else_block.name,\n    \t\ttype: \"else\",\n    \t\tsource: \"(201:8) {:else}\",\n    \t\tctx\n    \t});\n\n    \treturn block;\n    }\n\n    // (199:8) {#if !genreLock}\n    function create_if_block(ctx) {\n    \tlet h4;\n    \tlet t;\n\n    \tconst block = {\n    \t\tc: function create() {\n    \t\t\th4 = element(\"h4\");\n    \t\t\tt = text(/*genre*/ ctx[2]);\n    \t\t\tthis.h();\n    \t\t},\n    \t\tl: function claim(nodes) {\n    \t\t\th4 = claim_element(nodes, \"H4\", { class: true });\n    \t\t\tvar h4_nodes = children(h4);\n    \t\t\tt = claim_text(h4_nodes, /*genre*/ ctx[2]);\n    \t\t\th4_nodes.forEach(detach_dev);\n    \t\t\tthis.h();\n    \t\t},\n    \t\th: function hydrate() {\n    \t\t\tattr_dev(h4, \"class\", \"svelte-11rvpx5\");\n    \t\t\tadd_location(h4, file, 199, 12, 5958);\n    \t\t},\n    \t\tm: function mount(target, anchor) {\n    \t\t\tinsert_hydration_dev(target, h4, anchor);\n    \t\t\tappend_hydration_dev(h4, t);\n    \t\t},\n    \t\tp: function update(ctx, dirty) {\n    \t\t\tif (dirty & /*genre*/ 4) set_data_dev(t, /*genre*/ ctx[2]);\n    \t\t},\n    \t\td: function destroy(detaching) {\n    \t\t\tif (detaching) detach_dev(h4);\n    \t\t}\n    \t};\n\n    \tdispatch_dev(\"SvelteRegisterBlock\", {\n    \t\tblock,\n    \t\tid: create_if_block.name,\n    \t\ttype: \"if\",\n    \t\tsource: \"(199:8) {#if !genreLock}\",\n    \t\tctx\n    \t});\n\n    \treturn block;\n    }\n\n    function create_fragment(ctx) {\n    \tlet main;\n    \tlet h1;\n    \tlet t0;\n    \tlet t1;\n    \tlet div3;\n    \tlet div0;\n    \tlet legend0;\n    \tlet t2;\n    \tlet t3;\n    \tlet t4;\n    \tlet t5;\n    \tlet div1;\n    \tlet legend1;\n    \tlet t6;\n    \tlet t7;\n    \tlet t8;\n    \tlet t9;\n    \tlet div2;\n    \tlet legend2;\n    \tlet t10;\n    \tlet t11;\n    \tlet t12;\n    \tlet t13;\n    \tlet button;\n    \tlet t14;\n    \tlet t15;\n    \tlet footer;\n    \tlet div4;\n    \tlet t16;\n    \tlet a;\n    \tlet t17;\n    \tlet mounted;\n    \tlet dispose;\n\n    \tfunction select_block_type(ctx, dirty) {\n    \t\tif (!/*styleLock*/ ctx[3]) return create_if_block_5;\n    \t\treturn create_else_block_5;\n    \t}\n\n    \tlet current_block_type = select_block_type(ctx);\n    \tlet if_block0 = current_block_type(ctx);\n\n    \tfunction select_block_type_1(ctx, dirty) {\n    \t\tif (!/*styleLock*/ ctx[3]) return create_if_block_4;\n    \t\treturn create_else_block_4;\n    \t}\n\n    \tlet current_block_type_1 = select_block_type_1(ctx);\n    \tlet if_block1 = current_block_type_1(ctx);\n\n    \tfunction select_block_type_2(ctx, dirty) {\n    \t\tif (!/*themeLock*/ ctx[4]) return create_if_block_3;\n    \t\treturn create_else_block_3;\n    \t}\n\n    \tlet current_block_type_2 = select_block_type_2(ctx);\n    \tlet if_block2 = current_block_type_2(ctx);\n\n    \tfunction select_block_type_3(ctx, dirty) {\n    \t\tif (!/*themeLock*/ ctx[4]) return create_if_block_2;\n    \t\treturn create_else_block_2;\n    \t}\n\n    \tlet current_block_type_3 = select_block_type_3(ctx);\n    \tlet if_block3 = current_block_type_3(ctx);\n\n    \tfunction select_block_type_4(ctx, dirty) {\n    \t\tif (!/*genreLock*/ ctx[5]) return create_if_block_1;\n    \t\treturn create_else_block_1;\n    \t}\n\n    \tlet current_block_type_4 = select_block_type_4(ctx);\n    \tlet if_block4 = current_block_type_4(ctx);\n\n    \tfunction select_block_type_5(ctx, dirty) {\n    \t\tif (!/*genreLock*/ ctx[5]) return create_if_block;\n    \t\treturn create_else_block;\n    \t}\n\n    \tlet current_block_type_5 = select_block_type_5(ctx);\n    \tlet if_block5 = current_block_type_5(ctx);\n\n    \tconst block = {\n    \t\tc: function create() {\n    \t\t\tmain = element(\"main\");\n    \t\t\th1 = element(\"h1\");\n    \t\t\tt0 = text(\"Game Idea Generator\");\n    \t\t\tt1 = space();\n    \t\t\tdiv3 = element(\"div\");\n    \t\t\tdiv0 = element(\"div\");\n    \t\t\tlegend0 = element(\"legend\");\n    \t\t\tt2 = text(\"STYLE\");\n    \t\t\tt3 = space();\n    \t\t\tif_block0.c();\n    \t\t\tt4 = space();\n    \t\t\tif_block1.c();\n    \t\t\tt5 = space();\n    \t\t\tdiv1 = element(\"div\");\n    \t\t\tlegend1 = element(\"legend\");\n    \t\t\tt6 = text(\"THEME\");\n    \t\t\tt7 = space();\n    \t\t\tif_block2.c();\n    \t\t\tt8 = space();\n    \t\t\tif_block3.c();\n    \t\t\tt9 = space();\n    \t\t\tdiv2 = element(\"div\");\n    \t\t\tlegend2 = element(\"legend\");\n    \t\t\tt10 = text(\"GENRE\");\n    \t\t\tt11 = space();\n    \t\t\tif_block4.c();\n    \t\t\tt12 = space();\n    \t\t\tif_block5.c();\n    \t\t\tt13 = space();\n    \t\t\tbutton = element(\"button\");\n    \t\t\tt14 = text(\"GENERATE\");\n    \t\t\tt15 = space();\n    \t\t\tfooter = element(\"footer\");\n    \t\t\tdiv4 = element(\"div\");\n    \t\t\tt16 = text(\"Copyright 2021 - \");\n    \t\t\ta = element(\"a\");\n    \t\t\tt17 = text(\"ignurof.xyz\");\n    \t\t\tthis.h();\n    \t\t},\n    \t\tl: function claim(nodes) {\n    \t\t\tmain = claim_element(nodes, \"MAIN\", { class: true });\n    \t\t\tvar main_nodes = children(main);\n    \t\t\th1 = claim_element(main_nodes, \"H1\", { class: true });\n    \t\t\tvar h1_nodes = children(h1);\n    \t\t\tt0 = claim_text(h1_nodes, \"Game Idea Generator\");\n    \t\t\th1_nodes.forEach(detach_dev);\n    \t\t\tt1 = claim_space(main_nodes);\n    \t\t\tdiv3 = claim_element(main_nodes, \"DIV\", { class: true });\n    \t\t\tvar div3_nodes = children(div3);\n    \t\t\tdiv0 = claim_element(div3_nodes, \"DIV\", { class: true });\n    \t\t\tvar div0_nodes = children(div0);\n    \t\t\tlegend0 = claim_element(div0_nodes, \"LEGEND\", { class: true });\n    \t\t\tvar legend0_nodes = children(legend0);\n    \t\t\tt2 = claim_text(legend0_nodes, \"STYLE\");\n    \t\t\tlegend0_nodes.forEach(detach_dev);\n    \t\t\tt3 = claim_space(div0_nodes);\n    \t\t\tif_block0.l(div0_nodes);\n    \t\t\tdiv0_nodes.forEach(detach_dev);\n    \t\t\tt4 = claim_space(div3_nodes);\n    \t\t\tif_block1.l(div3_nodes);\n    \t\t\tt5 = claim_space(div3_nodes);\n    \t\t\tdiv1 = claim_element(div3_nodes, \"DIV\", { class: true });\n    \t\t\tvar div1_nodes = children(div1);\n    \t\t\tlegend1 = claim_element(div1_nodes, \"LEGEND\", { class: true });\n    \t\t\tvar legend1_nodes = children(legend1);\n    \t\t\tt6 = claim_text(legend1_nodes, \"THEME\");\n    \t\t\tlegend1_nodes.forEach(detach_dev);\n    \t\t\tt7 = claim_space(div1_nodes);\n    \t\t\tif_block2.l(div1_nodes);\n    \t\t\tdiv1_nodes.forEach(detach_dev);\n    \t\t\tt8 = claim_space(div3_nodes);\n    \t\t\tif_block3.l(div3_nodes);\n    \t\t\tt9 = claim_space(div3_nodes);\n    \t\t\tdiv2 = claim_element(div3_nodes, \"DIV\", { class: true });\n    \t\t\tvar div2_nodes = children(div2);\n    \t\t\tlegend2 = claim_element(div2_nodes, \"LEGEND\", { class: true });\n    \t\t\tvar legend2_nodes = children(legend2);\n    \t\t\tt10 = claim_text(legend2_nodes, \"GENRE\");\n    \t\t\tlegend2_nodes.forEach(detach_dev);\n    \t\t\tt11 = claim_space(div2_nodes);\n    \t\t\tif_block4.l(div2_nodes);\n    \t\t\tdiv2_nodes.forEach(detach_dev);\n    \t\t\tt12 = claim_space(div3_nodes);\n    \t\t\tif_block5.l(div3_nodes);\n    \t\t\tdiv3_nodes.forEach(detach_dev);\n    \t\t\tt13 = claim_space(main_nodes);\n    \t\t\tbutton = claim_element(main_nodes, \"BUTTON\", { class: true });\n    \t\t\tvar button_nodes = children(button);\n    \t\t\tt14 = claim_text(button_nodes, \"GENERATE\");\n    \t\t\tbutton_nodes.forEach(detach_dev);\n    \t\t\tt15 = claim_space(main_nodes);\n    \t\t\tfooter = claim_element(main_nodes, \"FOOTER\", { class: true });\n    \t\t\tvar footer_nodes = children(footer);\n    \t\t\tdiv4 = claim_element(footer_nodes, \"DIV\", { class: true });\n    \t\t\tvar div4_nodes = children(div4);\n    \t\t\tt16 = claim_text(div4_nodes, \"Copyright 2021 - \");\n    \t\t\ta = claim_element(div4_nodes, \"A\", { href: true, target: true, class: true });\n    \t\t\tvar a_nodes = children(a);\n    \t\t\tt17 = claim_text(a_nodes, \"ignurof.xyz\");\n    \t\t\ta_nodes.forEach(detach_dev);\n    \t\t\tdiv4_nodes.forEach(detach_dev);\n    \t\t\tfooter_nodes.forEach(detach_dev);\n    \t\t\tmain_nodes.forEach(detach_dev);\n    \t\t\tthis.h();\n    \t\t},\n    \t\th: function hydrate() {\n    \t\t\tattr_dev(h1, \"class\", \"svelte-11rvpx5\");\n    \t\t\tadd_location(h1, file, 147, 4, 2963);\n    \t\t\tattr_dev(legend0, \"class\", \"svelte-11rvpx5\");\n    \t\t\tadd_location(legend0, file, 152, 12, 3062);\n    \t\t\tattr_dev(div0, \"class\", \"field svelte-11rvpx5\");\n    \t\t\tadd_location(div0, file, 151, 8, 3029);\n    \t\t\tattr_dev(legend1, \"class\", \"svelte-11rvpx5\");\n    \t\t\tadd_location(legend1, file, 170, 12, 4072);\n    \t\t\tattr_dev(div1, \"class\", \"field svelte-11rvpx5\");\n    \t\t\tadd_location(div1, file, 169, 8, 4039);\n    \t\t\tattr_dev(legend2, \"class\", \"svelte-11rvpx5\");\n    \t\t\tadd_location(legend2, file, 187, 12, 5080);\n    \t\t\tattr_dev(div2, \"class\", \"field svelte-11rvpx5\");\n    \t\t\tadd_location(div2, file, 186, 8, 5047);\n    \t\t\tattr_dev(div3, \"class\", \"card svelte-11rvpx5\");\n    \t\t\tadd_location(div3, file, 149, 4, 2999);\n    \t\t\tattr_dev(button, \"class\", \"svelte-11rvpx5\");\n    \t\t\tadd_location(button, file, 206, 4, 6079);\n    \t\t\tattr_dev(a, \"href\", \"ignurof.xyz\");\n    \t\t\tattr_dev(a, \"target\", \"_blank\");\n    \t\t\tattr_dev(a, \"class\", \"svelte-11rvpx5\");\n    \t\t\tadd_location(a, file, 210, 29, 6214);\n    \t\t\tattr_dev(div4, \"class\", \"credits svelte-11rvpx5\");\n    \t\t\tadd_location(div4, file, 209, 8, 6162);\n    \t\t\tattr_dev(footer, \"class\", \"svelte-11rvpx5\");\n    \t\t\tadd_location(footer, file, 208, 4, 6144);\n    \t\t\tattr_dev(main, \"class\", \"svelte-11rvpx5\");\n    \t\t\tadd_location(main, file, 146, 0, 2951);\n    \t\t},\n    \t\tm: function mount(target, anchor) {\n    \t\t\tinsert_hydration_dev(target, main, anchor);\n    \t\t\tappend_hydration_dev(main, h1);\n    \t\t\tappend_hydration_dev(h1, t0);\n    \t\t\tappend_hydration_dev(main, t1);\n    \t\t\tappend_hydration_dev(main, div3);\n    \t\t\tappend_hydration_dev(div3, div0);\n    \t\t\tappend_hydration_dev(div0, legend0);\n    \t\t\tappend_hydration_dev(legend0, t2);\n    \t\t\tappend_hydration_dev(div0, t3);\n    \t\t\tif_block0.m(div0, null);\n    \t\t\tappend_hydration_dev(div3, t4);\n    \t\t\tif_block1.m(div3, null);\n    \t\t\tappend_hydration_dev(div3, t5);\n    \t\t\tappend_hydration_dev(div3, div1);\n    \t\t\tappend_hydration_dev(div1, legend1);\n    \t\t\tappend_hydration_dev(legend1, t6);\n    \t\t\tappend_hydration_dev(div1, t7);\n    \t\t\tif_block2.m(div1, null);\n    \t\t\tappend_hydration_dev(div3, t8);\n    \t\t\tif_block3.m(div3, null);\n    \t\t\tappend_hydration_dev(div3, t9);\n    \t\t\tappend_hydration_dev(div3, div2);\n    \t\t\tappend_hydration_dev(div2, legend2);\n    \t\t\tappend_hydration_dev(legend2, t10);\n    \t\t\tappend_hydration_dev(div2, t11);\n    \t\t\tif_block4.m(div2, null);\n    \t\t\tappend_hydration_dev(div3, t12);\n    \t\t\tif_block5.m(div3, null);\n    \t\t\tappend_hydration_dev(main, t13);\n    \t\t\tappend_hydration_dev(main, button);\n    \t\t\tappend_hydration_dev(button, t14);\n    \t\t\tappend_hydration_dev(main, t15);\n    \t\t\tappend_hydration_dev(main, footer);\n    \t\t\tappend_hydration_dev(footer, div4);\n    \t\t\tappend_hydration_dev(div4, t16);\n    \t\t\tappend_hydration_dev(div4, a);\n    \t\t\tappend_hydration_dev(a, t17);\n\n    \t\t\tif (!mounted) {\n    \t\t\t\tdispose = listen_dev(button, \"click\", /*click_handler_6*/ ctx[18], false, false, false);\n    \t\t\t\tmounted = true;\n    \t\t\t}\n    \t\t},\n    \t\tp: function update(ctx, [dirty]) {\n    \t\t\tif (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {\n    \t\t\t\tif_block0.p(ctx, dirty);\n    \t\t\t} else {\n    \t\t\t\tif_block0.d(1);\n    \t\t\t\tif_block0 = current_block_type(ctx);\n\n    \t\t\t\tif (if_block0) {\n    \t\t\t\t\tif_block0.c();\n    \t\t\t\t\tif_block0.m(div0, null);\n    \t\t\t\t}\n    \t\t\t}\n\n    \t\t\tif (current_block_type_1 === (current_block_type_1 = select_block_type_1(ctx)) && if_block1) {\n    \t\t\t\tif_block1.p(ctx, dirty);\n    \t\t\t} else {\n    \t\t\t\tif_block1.d(1);\n    \t\t\t\tif_block1 = current_block_type_1(ctx);\n\n    \t\t\t\tif (if_block1) {\n    \t\t\t\t\tif_block1.c();\n    \t\t\t\t\tif_block1.m(div3, t5);\n    \t\t\t\t}\n    \t\t\t}\n\n    \t\t\tif (current_block_type_2 === (current_block_type_2 = select_block_type_2(ctx)) && if_block2) {\n    \t\t\t\tif_block2.p(ctx, dirty);\n    \t\t\t} else {\n    \t\t\t\tif_block2.d(1);\n    \t\t\t\tif_block2 = current_block_type_2(ctx);\n\n    \t\t\t\tif (if_block2) {\n    \t\t\t\t\tif_block2.c();\n    \t\t\t\t\tif_block2.m(div1, null);\n    \t\t\t\t}\n    \t\t\t}\n\n    \t\t\tif (current_block_type_3 === (current_block_type_3 = select_block_type_3(ctx)) && if_block3) {\n    \t\t\t\tif_block3.p(ctx, dirty);\n    \t\t\t} else {\n    \t\t\t\tif_block3.d(1);\n    \t\t\t\tif_block3 = current_block_type_3(ctx);\n\n    \t\t\t\tif (if_block3) {\n    \t\t\t\t\tif_block3.c();\n    \t\t\t\t\tif_block3.m(div3, t9);\n    \t\t\t\t}\n    \t\t\t}\n\n    \t\t\tif (current_block_type_4 === (current_block_type_4 = select_block_type_4(ctx)) && if_block4) {\n    \t\t\t\tif_block4.p(ctx, dirty);\n    \t\t\t} else {\n    \t\t\t\tif_block4.d(1);\n    \t\t\t\tif_block4 = current_block_type_4(ctx);\n\n    \t\t\t\tif (if_block4) {\n    \t\t\t\t\tif_block4.c();\n    \t\t\t\t\tif_block4.m(div2, null);\n    \t\t\t\t}\n    \t\t\t}\n\n    \t\t\tif (current_block_type_5 === (current_block_type_5 = select_block_type_5(ctx)) && if_block5) {\n    \t\t\t\tif_block5.p(ctx, dirty);\n    \t\t\t} else {\n    \t\t\t\tif_block5.d(1);\n    \t\t\t\tif_block5 = current_block_type_5(ctx);\n\n    \t\t\t\tif (if_block5) {\n    \t\t\t\t\tif_block5.c();\n    \t\t\t\t\tif_block5.m(div3, null);\n    \t\t\t\t}\n    \t\t\t}\n    \t\t},\n    \t\ti: noop,\n    \t\to: noop,\n    \t\td: function destroy(detaching) {\n    \t\t\tif (detaching) detach_dev(main);\n    \t\t\tif_block0.d();\n    \t\t\tif_block1.d();\n    \t\t\tif_block2.d();\n    \t\t\tif_block3.d();\n    \t\t\tif_block4.d();\n    \t\t\tif_block5.d();\n    \t\t\tmounted = false;\n    \t\t\tdispose();\n    \t\t}\n    \t};\n\n    \tdispatch_dev(\"SvelteRegisterBlock\", {\n    \t\tblock,\n    \t\tid: create_fragment.name,\n    \t\ttype: \"component\",\n    \t\tsource: \"\",\n    \t\tctx\n    \t});\n\n    \treturn block;\n    }\n\n    function instance($$self, $$props, $$invalidate) {\n    \tlet { $$slots: slots = {}, $$scope } = $$props;\n    \tvalidate_slots('Routes', slots, []);\n    \tlet { gameIdeaObj } = $$props;\n    \tlet style = gameIdeaObj.style;\n    \tlet theme = gameIdeaObj.theme;\n    \tlet genre = gameIdeaObj.genre;\n    \tlet styleLock = false;\n    \tlet themeLock = false;\n    \tlet genreLock = false;\n    \tlet styleTempField;\n    \tlet themeTempField;\n    \tlet genreTempField;\n\n    \t// Request idea object from backend\n    \tconst FetchNewIdea = async () => {\n    \t\tlet response = await fetch(\"/generate\");\n    \t\tif (!response.ok) return console.error(\"Something went wrong with generate request!\");\n    \t\tlet result = await response.json();\n    \t\t$$invalidate(0, style = result.style);\n    \t\t$$invalidate(1, theme = result.theme);\n    \t\t$$invalidate(2, genre = result.genre);\n    \t};\n\n    \t// Change lock and update fields accordingly\n    \tconst ChangeLockStatus = fieldType => {\n    \t\tif (fieldType === \"style\") {\n    \t\t\tif (!styleLock) {\n    \t\t\t\t$$invalidate(6, styleTempField = style);\n    \t\t\t} else $$invalidate(0, style = styleTempField);\n\n    \t\t\t$$invalidate(3, styleLock = !styleLock);\n    \t\t}\n\n    \t\tif (fieldType === \"theme\") {\n    \t\t\tif (!themeLock) {\n    \t\t\t\t$$invalidate(7, themeTempField = theme);\n    \t\t\t} else $$invalidate(1, theme = themeTempField);\n\n    \t\t\t$$invalidate(4, themeLock = !themeLock);\n    \t\t}\n\n    \t\tif (fieldType === \"genre\") {\n    \t\t\tif (!genreLock) {\n    \t\t\t\t$$invalidate(8, genreTempField = genre);\n    \t\t\t} else $$invalidate(2, genre = genreTempField);\n\n    \t\t\t$$invalidate(5, genreLock = !genreLock);\n    \t\t}\n    \t};\n\n    \tconst writable_props = ['gameIdeaObj'];\n\n    \tObject.keys($$props).forEach(key => {\n    \t\tif (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<Routes> was created with unknown prop '${key}'`);\n    \t});\n\n    \tconst click_handler = () => ChangeLockStatus(\"style\");\n    \tconst click_handler_1 = () => ChangeLockStatus(\"style\");\n    \tconst click_handler_2 = () => ChangeLockStatus(\"theme\");\n    \tconst click_handler_3 = () => ChangeLockStatus(\"theme\");\n    \tconst click_handler_4 = () => ChangeLockStatus(\"genre\");\n    \tconst click_handler_5 = () => ChangeLockStatus(\"genre\");\n    \tconst click_handler_6 = () => FetchNewIdea();\n\n    \t$$self.$$set = $$props => {\n    \t\tif ('gameIdeaObj' in $$props) $$invalidate(11, gameIdeaObj = $$props.gameIdeaObj);\n    \t};\n\n    \t$$self.$capture_state = () => ({\n    \t\tgameIdeaObj,\n    \t\tstyle,\n    \t\ttheme,\n    \t\tgenre,\n    \t\tstyleLock,\n    \t\tthemeLock,\n    \t\tgenreLock,\n    \t\tstyleTempField,\n    \t\tthemeTempField,\n    \t\tgenreTempField,\n    \t\tFetchNewIdea,\n    \t\tChangeLockStatus\n    \t});\n\n    \t$$self.$inject_state = $$props => {\n    \t\tif ('gameIdeaObj' in $$props) $$invalidate(11, gameIdeaObj = $$props.gameIdeaObj);\n    \t\tif ('style' in $$props) $$invalidate(0, style = $$props.style);\n    \t\tif ('theme' in $$props) $$invalidate(1, theme = $$props.theme);\n    \t\tif ('genre' in $$props) $$invalidate(2, genre = $$props.genre);\n    \t\tif ('styleLock' in $$props) $$invalidate(3, styleLock = $$props.styleLock);\n    \t\tif ('themeLock' in $$props) $$invalidate(4, themeLock = $$props.themeLock);\n    \t\tif ('genreLock' in $$props) $$invalidate(5, genreLock = $$props.genreLock);\n    \t\tif ('styleTempField' in $$props) $$invalidate(6, styleTempField = $$props.styleTempField);\n    \t\tif ('themeTempField' in $$props) $$invalidate(7, themeTempField = $$props.themeTempField);\n    \t\tif ('genreTempField' in $$props) $$invalidate(8, genreTempField = $$props.genreTempField);\n    \t};\n\n    \tif ($$props && \"$$inject\" in $$props) {\n    \t\t$$self.$inject_state($$props.$$inject);\n    \t}\n\n    \treturn [\n    \t\tstyle,\n    \t\ttheme,\n    \t\tgenre,\n    \t\tstyleLock,\n    \t\tthemeLock,\n    \t\tgenreLock,\n    \t\tstyleTempField,\n    \t\tthemeTempField,\n    \t\tgenreTempField,\n    \t\tFetchNewIdea,\n    \t\tChangeLockStatus,\n    \t\tgameIdeaObj,\n    \t\tclick_handler,\n    \t\tclick_handler_1,\n    \t\tclick_handler_2,\n    \t\tclick_handler_3,\n    \t\tclick_handler_4,\n    \t\tclick_handler_5,\n    \t\tclick_handler_6\n    \t];\n    }\n\n    class Routes extends SvelteComponentDev {\n    \tconstructor(options) {\n    \t\tsuper(options);\n    \t\tinit(this, options, instance, create_fragment, safe_not_equal, { gameIdeaObj: 11 });\n\n    \t\tdispatch_dev(\"SvelteRegisterComponent\", {\n    \t\t\tcomponent: this,\n    \t\t\ttagName: \"Routes\",\n    \t\t\toptions,\n    \t\t\tid: create_fragment.name\n    \t\t});\n\n    \t\tconst { ctx } = this.$$;\n    \t\tconst props = options.props || {};\n\n    \t\tif (/*gameIdeaObj*/ ctx[11] === undefined && !('gameIdeaObj' in props)) {\n    \t\t\tconsole_1.warn(\"<Routes> was created without expected prop 'gameIdeaObj'\");\n    \t\t}\n    \t}\n\n    \tget gameIdeaObj() {\n    \t\tthrow new Error(\"<Routes>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n    \t}\n\n    \tset gameIdeaObj(value) {\n    \t\tthrow new Error(\"<Routes>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n    \t}\n    }\n\n    return Routes;\n\n})();\n",
            "dynamicImports": [],
            "fileName": "index.js",
            "implicitlyLoadedBefore": [],
            "importedBindings": {},
            "imports": [],
            "map": null,
            "referencedFiles": []
        },
        "watchFiles": [
            "C:\\Users\\ignur\\Desktop\\Portfolio\\gameidea-generator\\src\\routes\\index.svelte",
            "C:\\Users\\ignur\\Desktop\\Portfolio\\gameidea-generator\\src\\routes\\index.css",
            "C:\\Users\\ignur\\Desktop\\Portfolio\\gameidea-generator\\node_modules\\svelte\\internal\\index.mjs"
        ]
    },
    "hashes": {
        "js": "2666b4cfb0c9155fdb6701e4aeec8608",
        "css": "2946dd615ef070d1010c4c98c7a41aad"
    }
}